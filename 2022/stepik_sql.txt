1.2
--------------------------------------------------

Задание
При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать new_price. Значение округлить до двух знаков после запятой.

/*select title, amount, price,
    round(if(amount<4, (price * 0.5), if(amount<11, price * 0.7, price*0.9)), 2) as sale,
    if(amount < 4, 'скидка 50%', if(amount < 11, 'скидка 30%', 'скидка 10%')) as Ваша_скидка 
from book; */
select author, title, round(if(author = 'Булгаков М.А.', price * 1.1, if(author = 'Есенин С.А.', price * 1.05, price)), 2) as new_price
from book;

----------------------------------------------------------------------------------------------------

Вывести автора, название  и цены тех книг, количество которых меньше 10.

select author, title, price
from book
where amount < 10;

------------------------------------------------------------------------------------------------------               

Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

/*select title, author, price
from book
where author = 'Булгаков М.А.' and price > 600;    
select title, author, price
from book
where (author = 'Есенин С.А.' or author = 'Булгаков М.А.') and price > 600;*/

select title, author, price, amount
from book
where (price < 500 or price > 600) and (price*amount >= 5000);

------------------------------------------------------------------------------------------------------               

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

select title, author
from book
where (price between 540.50 and 800) and (amount in (2,3,5,7));

------------------------------------------------------------------------------------------------------               

Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

select author, title
from book
where amount between 2 and 14
order by author desc, title;

------------------------------------------------------------------------------------------------------               

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

select title, author
  from book
 where title like '_% _%' 
   and (author like '% С._.'
    or author like '% _.С.')
 order by title;
   
------------------------------------------------------------------------------------------------------               -

Придумайте один или несколько запросов к нашей таблице book. Проверьте, правильно ли они работают.

select author
from book
group by author

------------------------------------------------------------------------------------------------------ 
Отобрать различные (уникальные) элементы столбца amount таблицы book.

select distinct amount
from book;

--------------------------------------

Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

select author as Автор, count(author) as Различных_книг, sum(amount) as Количество_экземпляров
from book
group by author;

------------------------------------------------------------------------------------------------------               
			Выборка данных, групповые функции MIN, MAX и AVG

Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.

select author, min(price) as Минимальная_цена, max(price) as Максимальная_цена, avg(price) as Средняя_цена
from book
group by author;

------------------------------------------------------------------------------------------------------               
			Выборка данных c вычислением, групповые функции		
Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой. В запросе для расчета НДС(tax)  и Стоимости без НДС(S_without_tax) использовать следующие формулы: 
tax=((s*k/100)/(1+k/100)
S_without_tax = (s/(1+k/100))

select author, sum(price * amount) as Стоимость
     , round((sum(price * amount) * 0.18/1.18),2) as НДС
     , round(((sum(price * amount))/1.18),2) as Стоимость_без_НДС  
from book
group by author;

------------------------------------------------------------------------------------------------------               
			Вычисления по таблице целиком
Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой. Пояснение. В задании нужно посчитать среднюю цену уникальных книг на складе, а не среднюю цену всех экземпляров книг.

select 
	min(price) as Минимальная_цена
       ,max(price) as Максимальная_цена
       ,round(((sum(price))/count(author)),2) as Средняя_цена
from book
--group by author;
------------------------------------------------------------------------------------------------------               
			Выборка данных по условию, групповые функции
Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.

select
    round(avg(price),2) as Средняя_цена
   ,round(sum(price * amount),2) as Стоимость
from book
where amount between 5 and 14;


------------------------------------------------------------------------------------------------------               
			Выборка данных по условию, групповые функции, WHERE и HAVING

Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.

select author, sum(price * amount) as Стоимость
from book
where title <> 'Идиот' and title <> 'Белая гвардия'
group by author
having sum(price * amount) > 5000  
--так то тут неправильно, должно было быть having round(sum(price * amount) > 5000
order by sum(price * amount) desc

------------------------------------------------------------------------------------------------------               
			Вложенный запрос, возвращающий одно значение
Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

select author, title, price
from book
where price <= (select avg(price) from book) 
order by price desc;

------------------------------------------------------------------------------------------------------               
			Использование вложенного запроса в выражении
Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.

select author, title, price
from book
where (price - (select min(price) from book)) <= 150
order by price
------------------------------------------------------------------------------------------------------               
			Вложенный запрос, оператор IN
Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется. Пояснение в решению: во вложенном запросе отберите те значения столбца amount, количество которых, вычисленное с помощью функции count(), равно 1. 

select author, title, amount
from book
where amount in (select amount
                 from book
                 group by amount
                 having count(amount) = 1
                );
------------------------------------------------------------------------------------------------------               
			Вложенный запрос, операторы ANY и ALL (только во вложенном можно использовать any и all)
Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.

select author, title, price
from book
where price < any(
                    select min(price)
                    from book
                    group by author
                    );

------------------------------------------------------------------------------------------------------               
				Вложенный запрос после SELECT
Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно.

select title, author, amount,(
    (
        select max(amount)
        from book)
        - amount) as Заказ
from book
where ((select max(amount) from book) - amount) > 0;

------------------------------------------------------------------------------------------------------               
Создание таблицы осуществляется с помощью запроса CREATE, подробно рассмотренного в первом уроке модуля.

create table supply(
     supply_id int primary key auto_increment
    ,title varchar(50)
    ,author varchar(30)
    ,price decimal(8,2)
    ,amount int
    );


------------------------------------------------------------------------------------------------------               
				Добавление записей в таблицу
Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:

insert into supply(title, author, price, amount)
values
    ('Лирика', 'Пастернак Б.Л.', 518.99, 2)
   ,('Черный человек', 'Есенин С.А.', 570.20, 6)
   ,('Белая гвардия', 'Булгаков М.А.', 540.50, 7)
   ,('Идиот', 'Достоевский Ф.М.', 360.80, 3);
------------------------------------------------------------------------------------------------------               
				Добавление записей из другой таблицы
Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

insert into book (title, author, price, amount)
select title, author, price, amount
from supply
where author not in ('Булгаков М.А.', 'Достоевский Ф.М.')
------------------------------------------------------------------------------------------------------               
				Добавление записей, вложенные запросы
Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.
(также пришлось убрать автора Есенин С.А, так как в результирущем ответе его не должно было быть)

insert into book (title, author, price, amount)
select title, author, price, amount
from supply
where title not in(
    select title
    from book
    ) and not author = 'Есенин С.А.'; 
select * from book


------------------------------------------------------------------------------------------------------               
				Запросы на обновление
Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы.

update book
set price = 0.9 * price
where amount between 5 and 10;
select * from book;


------------------------------------------------------------------------------------------------------               
				Запросы на обновление нескольких столбцов
В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.

update book
set buy = if(buy >= amount, amount, buy)
   ,price = if(buy > 0, price, 0.9*price);
select * from book;

------------------------------------------------------------------------------------------------------               
				Запросы на обновление нескольких таблиц
В запросах на обновление можно использовать несколько таблиц, но тогда

    для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
    все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
    в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.

Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).

update book, supply
set book.amount = book.amount + supply.amount
   ,book.price = (book.price + supply.price)/2
where book.title = supply.title and book.author = supply.author;

select * from book;

------------------------------------------------------------------------------------------------------               
				Запросы на удаление
Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.

DELETE FROM supply 
WHERE author IN (
        SELECT author 
        FROM book
        group by author
        having sum(amount) > 10
          );

select * from supply;

------------------------------------------------------------------------------------------------------               
				Запросы на создание таблицы
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE.Запрос на создание новой таблицы имеет вид: 
CREATE TABLE имя_таблицы AS
SELECT ...

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

create table ordering as
select author, title, (select round(avg(amount))
                      from book) as amount
from book
where book.amount < (select round(avg(amount))
                    from book);

select * from ordering;

------------------------------------------------------------------------------------------------------               
				1.6
Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

select name, city, per_diem, date_first, date_last
from trip
where name like '%а _._.'
order by date_last desc;

------------------------------------------------------------------------------------------------------               
Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.

select distinct name
from trip
where city = 'Москва'
order by name;

------------------------------------------------------------------------------------------------------               
Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. 

select city, count(city) as Количество 
from trip
group by city
order by city;

------------------------------------------------------------------------------------------------------               
				Оператор LIMIT
Для ограничения вывода записей в SQL используется оператор LIMIT , после которого указывается количество строк.  Результирующая таблица будет иметь количество строк не более указанного после LIMIT. LIMIT размещается после раздела ORDER BY. Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 
Важно. Оператор LIMIT нужно использовать очень осторожно. Например, если бы в таблице trip было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.

------------------------------------------------------------------------------------------------------               
				Оператор LIMIT
Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.

select city, count(city) as Количество
from trip
group by city
order by count(city) desc
limit 2;

------------------------------------------------------------------------------------------------------               
Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

Немного теории
Для вычитания двух дат используется функция DATEDIFF(дата_1, дата_2), результатом которой является количество дней между дата_1 и дата_2. Увеличьте разницу на 1, чтобы включить первый день командировки.

select name, city, (datediff(date_last, date_first) + 1) as Длительность
from trip
where city not in('Москва', 'Санкт-Петербург')
order by 3 desc, city desc

------------------------------------------------------------------------------------------------------               
Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить столбцы name, city, date_first, date_last. Пояснение: используйте вложенный запрос, чтобы найти длительность самой короткой командировки. 

select name, city, date_first, date_last
from trip
where datediff(date_last, date_first) = (select min(datediff(date_last, date_first))
                                         from trip
                                        order by 1);

------------------------------------------------------------------------------------------------------               

Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .
	Немного теории: для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).
Например, MONTH('2020-04-12') = 4.
Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)

select name, city, date_first, date_last
from trip
where month(date_first) = month(date_last)
order by city, name;

------------------------------------------------------------------------------------------------------               
Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Немного теории

    Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название месяца на английском языке для указанной даты. Например, MONTHNAME('2020-04-12')='April'.
    Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после GROUP BYможно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS. Важно отметить, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

select monthname(date_first) as Месяц, count(monthname(date_first)) as Количество
from trip
group by monthname(date_first)
order by count(monthname(date_first)) desc, monthname(date_first) 

------------------------------------------------------------------------------------------------------               
Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem. Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

select name, city, date_first, (per_diem * (datediff(date_last, date_first)+1)) as Сумма
from trip
where month(date_first) = 2 or month(date_first) = 3 
order by name, 4 desc;

------------------------------------------------------------------------------------------------------               
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма.

select name, sum((datediff(date_last, date_first) + 1) * per_diem) as Сумма 
from trip
group by name
having count(name) > 3
order by 2 desc

------------------------------------------------------------------------------------------------------               
https://stepik.org/lesson/305762/step/2?unit=287773
Создать таблицу fine следующей структуры:

create table fine (
                     fine_id INT PRIMARY KEY AUTO_INCREMENT
                    , name varchar(30)
                    , number_plate varchar(6)
                    , violation varchar(50)
                    , sum_fine decimal(8,2)
                    , date_violation date
                    , date_payment date 
                  );

------------------------------------------------------------------------------------------------------               
https://stepik.org/lesson/305762/step/3?unit=287773
В таблицу fine первые 5 строк уже занесены. Добавить в таблицу записи с ключевыми значениями 6, 7, 8.

insert into fine(name, number_plate, violation, sum_fine, date_violation, date_payment)
    values  ('Баранов П.Е.', 'Р523ВТ', 'Превышение скорости(от 40 до 60)', null, '2020-02-14', null)
           ,('Абрамова К.А.', 'О111АВ', 'Проезд на запрещающий сигнал', null, '2020-02-23', null)
           ,('Яковлев Г.Р.', 'Т330ТТ', 'Проезд на запрещающий сигнал', null, '2020-03-03', null);
------------------------------------------------------------------------------------------------------               
			Использование временного имени таблицы (алиаса)


Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.
Таблица traffic_violationсоздана и заполнена.
Важно! Сравнение значения столбца с пустым значением осуществляется с помощью оператора IS NULL.

update fine as f, traffic_violation as tv
set f.sum_fine = tv.sum_fine
where f.sum_fine is null 
and f.violation = tv.violation;

select * from fine;
------------------------------------------------------------------------------------------------------               
				Группировка данных по нескольким столбцам
В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:
((((((((((	Важно! В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не (((((((((       применяются (групповые функции) из SELECT.				)))))))))))))
Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.
Пояснение

Под увеличение  штрафа в два раза подходит водитель «Абрамова К.А.», который на машине с государственным номером «О111АВ» совершил повторное нарушение «Проезд на запрещающий сигнал», а также водитель  «Баранов П.Е.» , который на машине с номером  «Р523ВТ» дважды совершил нарушение «Превышение скорости(от 40 до 60) ».

select f.name, f.number_plate, f.violation  
from fine as f
group by f.name, f.number_plate, f.violation
having count(f.number_plate) = 2 
order by name, number_plate, violation;

------------------------------------------------------------------------------------------------------               
	В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 

    Для всех нарушений, по которым штраф еще не оплачен, (тех, у которых date_payment имеет пустое значение Null), необходимо проверить, является ли данное нарушение для водителя и машины повторным, если да –  увеличить штраф в два раза.
    Если водитель совершил нарушение на другой машине, ему увеличивать штраф не нужно.
    Если несколько повторных нарушений не оплачены, то штраф увеличить для всех.
    Этот запрос реализован на предыдущем шаге.
При реализации можно использовать вложенный запрос как отдельную таблицу, записанную после ключевого слова UPDATE, при этом вложенному запросу необходимо присвоить имя, например query_in:

UPDATE fine, 
    (
     SELECT ...
    ) query_in
SET ...
WHERE указать, что совпадают нарушение, фамилия водителя и номер машины в таблицах fine и вложенном запросе query_in соответственно, а также дата оплаты в таблице fine пуста

Другим способом решения является использование двух запросов: сначала создать временную таблицу, например query_in, в которую включить информацию о тех штрафах, сумму которых нужно увеличить в два раза, а затем уже обновлять информацию в таблице fine:

CREATE TABLE query_in ...;
UPDATE fine, query_in
SET ...
WHERE ...;

После ключевого слова WHERE  указывается условие, при котором нужно обновлять данные. В нашем случае  данные обновляются, если и фамилия, и государственный номер, и нарушение совпадают в таблице fine и в результирующей таблице запроса query_in. Например, для связи по фамилии используется запись fine.name = query_in.name. Также в условии нужно учесть, что данные обновляются только для тех записей, у которых в столбце date_payment пусто.
Важно! Если в запросе используется несколько таблиц или запросов, включающих одинаковые поля, то применяется полное имя столбца, включающего название таблицы через символ «.». Например,  fine.name  и  query_in.name.

create table query_in as (select f.name, f.number_plate, f.violation
                          from fine as f
                          group by f.name, f.number_plate, f.violation
                          having count(*) > 1);
update fine as f, query_in as q
set sum_fine = sum_fine * 2
where f.date_payment is null and
(f.name, f.number_plate, f.violation) = (q.name, q.number_plate, q.violation);
select * from fine;


-- или where f.date_payment is null and f.name = q.name and f.number_plate = q.number_plate and f.violation = --q.violation;
вот это решение ниже, тоже верное

update fine as f, (select f.name, f.number_plate, f.violation
                          from fine as f
                          group by f.name, f.number_plate, f.violation
                          having count(*) > 1) as query_in
set sum_fine = sum_fine * 2
where f.date_payment is null and
(f.name, f.number_plate, f.violation) = (query_in.name, query_in.number_plate, query_in.violation);
select * from fine;

------------------------------------------------------------------------------------------------------               
Задание
Необходимо:
    в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
    уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов, информация о которых занесена в таблицу payment) , если оплата произведена не позднее 20 дней со дня нарушения.

 update fine as f, payment as p
    set f.date_payment = p.date_payment,
        f.sum_fine = if(datediff(p.date_payment, p.date_violation) < 20+1, 0.5 * f.sum_fine, f.sum_fine)
  where f.name = p.name
    and f.number_plate = p.number_plate
    and f.violation = p.violation
    and f.date_payment is null;
 select * from fine;

------------------------------------------------------------------------------------------------------               
Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

create table back_payment as
select f.name, f.number_plate, f.violation, f.sum_fine, f.date_violation
from fine as f
where f.date_payment is null;
select * from back_payment;

------------------------------------------------------------------------------------------------------               
Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 

delete from fine
where date_violation < '2020-02-01 ';
select * from fine;

------------------------------------------------------------------------------------------------------               

Поиск по ключевым словам

На данном шаге можно найти шаги курса, в которых встречаются ключевые слова SQL, которые рассматриваются в курсе.

Для этого скопируйте один из запросов в окно решений, укажите нужные ключевые слова и запустите запрос. В окне решений будут выведены ссылки на соответствующие шаги.

Это НЕ ЗАДАНИЕ, а просто запросы, с помощью которых можно найти шаги, в которых встречаются те или иные ключевые слова. Выполнять не обязательно (это задание оценивается в 0 баллов). Это ПРОСТО ПОМОЩЬ для навигации по курсу.

Запрос 1. Поиск шагов, в которых встречается заданное ключевое слово, в примере MAX:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ", CONCAT(LEFT(step_name, 50), '...')) AS Шаг,
   note AS Примечание
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name = 'MAX'
ORDER BY 1;

Запрос 2. Поиск шагов, в которых встречаются два заданных ключевых слова одновременно, в примере MAX и AVG:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ", CONCAT(LEFT(step_name, 30), '...')) AS Шаг, 
   link AS Ссылка_на_шаг
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG')
GROUP BY ШАГ, Ссылка_на_шаг
HAVING count(*) = 2
ORDER BY 1;

 Запрос 3. Поиск шагов, в которых встречаются три заданных ключевых слова одновременно, в примере MAX, MIN и AVG:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ",step_name) AS Шаг
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG', 'MIN')
GROUP BY ШАГ
HAVING COUNT(*) = 3
ORDER BY 1;


------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------                 
				2.1. СВЯЗИ МЕЖДУ ТАБЛИЦАМИ

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы. 
Этапы реализации связи «один ко многим» на примере:
	1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе.
	2. Обе таблицы должны содержать первичный ключ (PK): book_id - в таблице  book,  author_id -  в таблице author.
	3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id)
------------------------------------------------------------------------------------------------------               
Создать таблицу author следующей структуры:

create table author (author_id int primary key auto_increment,
                     name_author varchar(50)
                    );


------------------------------------------------------------------------------------------------------               
Заполнить таблицу author. В нее включить следующих авторов:

    Булгаков М.А.
    Достоевский Ф.М.
    Есенин С.А.
    Пастернак Б.Л.

insert into author (name_author)
values ('Булгаков М.А.'),
       ('Достоевский Ф.М.'),
       ('Есенин С.А.'),
       ('Пастернак Б.Л.');


------------------------------------------------------------------------------------------------------               
Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре, показанной на логической схеме (таблица genre уже создана, порядок следования столбцов - как на логической схеме в таблице book, genre_id  - внешний ключ) . Для genre_id ограничение о недопустимости пустых значений не задавать. В качестве главной таблицы для описания поля  genre_idиспользовать таблицу genre следующей структуры:

create table book (book_id int primary key auto_increment,
                   title varchar(50),
                   author_id int not null,
                   genre_id int,
                   price decimal(8, 2),
                   amount int,
                   foreign key(author_id) references author(author_id),
                   foreign key(genre_id) references genre(genre_id)
                   );


------------------------------------------------------------------------------------------------------               
Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 

create table book (
    book_id int primary key auto_increment,
    title varchar(50),
    author_id int not null,
    genre_id int,
    price decimal(8,2),
    amount int,
    foreign key (author_id) references author (author_id) on delete cascade,
    foreign key (genre_id) references genre (genre_id) on delete set null
);
------------------------------------------------------------------------------------------------------               
Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:

insert into book (title, author_id, genre_id, price, amount)
values ('Стихотворения и поэмы', 3, 2, 650.00, 15),
       ('Черный человек', 3, 2, 570.20, 6),
       ('Лирика', 4, 2, 518.99, 2);
select * from book;

------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------                 
			2.2 Соединение INNER JOIN
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

select title, name_genre, price
from book as b
inner join genre as g on g.genre_id = b.genre_id
where amount > 8
order by price desc

------------------------------------------------------------------------------------------------------               
			    Вывести все жанры, которые не представлены в книгах на складе.

/*select
...
from 
    таблица_1 left join таблица_2
    on условие
... */
/* 
select name_author, title
from author left join book
    on author.author_id = book.author_id
order by name_author; 

--ниже то же самое, только переставил таблица, куда джонйнят (book)

select name_author, title
from book left join author on author.author_id = book.author_id
order by name_author;
select * from author;
select * from book;
*/
select name_genre
from genre as g left join book as b on g.genre_id = b.genre_id
where b.title is null;

с комментариев интересное решениепри помощи exists
SELECT g.name_genre
FROM genre g
WHERE NOT EXISTS(SELECT * from book b WHERE b.genre_id = g.genre_id);

------------------------------------------------------------------------------------------------------               
					Перекрестное соединение CROSS JOIN
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

select c.name_city, a.name_author, date_add('2020-01-01', interval (floor(rand() * 365)) day) as Дата
from city as c, author as a
--date_add('2020-01-01', interval floor(rand() * 365)) --прибавляем к начальной дате 2020-01-01 сгенерированное 
-- число
order by c.name_city, 3 desc

------------------------------------------------------------------------------------------------------               
					Запросы на выборку из нескольких таблиц
 Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

/*
table first ------>  table second (в первой таблице есть первичный ключ как и во второй, внешний ключ во второй таблице)
table second ----->  table third (--//--- как и в first ----> second)
*/
/*
select
...
from 
    first
    inner join second on first.first_id = second.first_id
    inner join third on second.second_id = third.second_id;
*/
/*
table first ------>   table third
table second ----->   table third
у каждого есть первичный ключ, первая и вторая указыают на третью на внешний ключ.
*/
/*
select
...
from 
    first
    inner join third on first.first_id = third.first_id
    inner join second on second.second_id = third.second_id;  
*/   
select g.name_genre, b.title, a.name_author
from 
    genre as g 
    inner join book as b on g.genre_id = b.genre_id
    inner join author as a on a.author_id = b.author_id
where g.name_genre = 'Роман'
order by title

------------------------------------------------------------------------------------------------------               
				Запросы для нескольких таблиц с группировкой

Посчитать количество экземпляров  книг каждого автора из таблицы author.  Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.

/* из-за inner не входят в выборку авторы, у которых нет книг
    select name_author, count(title) as Количество
    from author inner join book on author.author_id = book.author_id
    group by name_author
    order by name_author;
*/
/* сюда же авторы без книг уже входят
select name_author, count(title) as Количество
from 
    author left join book on author.author_id = book.author_id
group by name_author
order by name_author;
*/

select a.name_author, sum(b.amount) as Количество
from author as a left join book as b on a.author_id = b.author_id
group by a.name_author
having (sum(b.amount) < 10 or sum(b.amount) is null)
order by sum(b.amount);
------------------------------------------------------------------------------------------------------               
--Пример, вывести авторов, общее количество книг которых на складе максимаьно
/*    это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объеденим все запросы в один.
    Шаг 1. Найдем суммарное колиечество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id
*/
select b.author_id, sum(b.amount) as sum_amount
from book as b
group by b.author_id;
/* 
    Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присовить имя (например, query_in) и использовать его в качестве таблицы-источника после from. Затем уже находить максимум по столбцу sum_amount.
*/
select max(sum_amount) as max_sum_amount
from 
    (
     select b.author_id, sum(b.amount) as sum_amount
    from book as b
    group by b.author_id
    ) query_in;
/* Теперь собственно осталось только добавить к этому результату нижнему автора книги (мои мысли)
    Шаг 3. (теперь уже из курса) выведем фамилию автора и общее количество книг для него
*/
select a.name_author, sum(amount) as Количество
from author as a 
    inner join book as b on a.author_id = b.author_id
group by a.name_author;

/*
    Шаг 4. Включим запрос с шаг 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количесвто книг которых максимально
*/

select a.name_author, sum(amount) as Количество
from author as a 
    inner join book as b on a.author_id = b.author_id
group by a.name_author
having sum(amount) = 
    ( /*вычисляем максимальное из общего количества книг каждого автора */
        select max(sum_amount) as max_sum_amount
        from 
            (/* считаем количество книг каждого автора */
             select b.author_id, sum(b.amount) as sum_amount
             from book as b
             group by b.author_id
            ) query_in
    );
				




Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).
------------------------------------------------------------------------------------------------------               
				Запросы для нескольких таблиц со вложенными запросами

/*Задача :вывести авторов, общее количество книг которых на складе максимально

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один
*//*

шаг 1. 
Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии авторов в этой таблице нет, то группировку будем осуществлять по author_id */
select b.author_id, sum(b.amount) as sum_amount
from book as b
group by b.author_id;
/*

Шаг 2. В результрирущей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать его в качестве таблицы-источника после from. Затем уже находить максимум по столбцу sum_amount. */
select max(query_in.sum_amount) as max_sam_amount
from (
    select b.author_id, sum(b.amount) as sum_amount
    from book as b
    group by b.author_id
    ) query_in;

/*Шаг 3. Выведем фамилию автора и общее количество книг для него*/
select a.name_author, sum(b.amount) as Количество
from author as a inner join book as b on a.author_id = b.author_id
group by a.name_author;

/*Шаг 4. Включим в запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.*/
select a.name_author, sum(b.amount) as Количество
from author as a inner join book as b on a.author_id = b.author_id
group by a.name_author
having sum(b.amount) = 
    (/* вычисляем максимальное из общего количества книг каждого автора */
        select max(sum_amount) as max_sum_amount
        from 
            (/* считаем количество книг каждого автора */
                select b.author_id, sum(b.amount) as sum_amount
                from book as b
                group by b.author_id
                ) query_in
    );    

/*ЗАДАНИЕ
Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблице так занесены данные, что у каждого автора книги только в одном жанре, для этого запроса внесем изменеия в таблицу book. Пусть у нас книга Есенина "Черный человек" относится к жанру "Роман", а книга Булгакова "Белая гвардия" к "Приключениям" (эти изменеия в таблицы уже внесены) 
Решение
Шаг 1. выведем авторов и в каком жанре они пишут, сгруппируем по author_id (То есть нам нужно вытащить теперь автора под author_id 2 и 4, так как у них жанр только один)*/

select a.name_author 
from (
    select tt.author_id
    from 
        (/*Выведем авторов и жанр в котором они пишут, сгруппировав их по author_id */
        select b.author_id, b.genre_id
        from book as b
        group by b.author_id, b.genre_id
        ) tt
    group by tt.author_id
    having count(tt.genre_id) = 1 -- выводим только тех авторов, кто пишет только в одном жанре
    ) bb inner join author as a on a.author_id = bb.author_id /*вместо author_id выводим самих авторов*/  
order by bb.author_id    

------------------------------------------------------------------------------------------------------               
			Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения JOIN.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...

/*Пример
Выведем авторов, пишущих книги в самом популярном жанре (жанр, у которого(ых) количество книг на складе максимально). Указать этот жанр.

Шаг 1. Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя
Запрос
*/
select b.genre_id, sum(b.amount) as sum_amount
from book as b
group by b.genre_id
order by sum_amount desc
limit 1;
/*Кажется, что, уже используя этот запрос, можно получить id самого полулярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтму нам необходим запрос, который отберет все жанры, саммарное количество которых равно sum_amount

Шаг 2.Используя запрос с шага 1, найдем id самых популярных жанров
*/
select query_in_1.genre_id
from 
    (/* Выбираем код жанра и количество произведений, относящихся к нему */
      select b.genre_id, sum(b.amount) as sum_amount
      from book as b
      group by b.genre_id
    ) query_in_1 inner join (
        /* выбираем запись, в котором указан код жанр с максимальным количеством книг*/
        select b.genre_id, sum(b.amount) as sum_amount
        from book as b
        group by b.genre_id
        order by sum_amount desc
        limit 1
        ) query_in_2 on query_in_1.sum_amount = query_in_2.sum_amount;

/* Шаг 3
Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и название этих жанров. В этом запросе обязательно выполнить группировку по фамилии авторов и id жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре*/
select a.name_author, g.name_genre
from author as a
    inner join book as b on a.author_id = b.author_id
    inner join genre as g on b.genre_id = g.genre_id
group by a.name_author, g.name_genre, g.genre_id
having g.genre_id in 
        (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
            select query_in_1.genre_Id
            from 
                (select genre_id, sum(amount) as sum_amount
                 from book
                 group by genre_id              
                ) query_in_1 inner join
                (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                select genre_id, sum(amount) as sum_amount
                    from book
                    group by genre_id
                    order by sum_amount desc
                    limit 1
                ) query_in_2 on query_in_1.sum_amount = query_in_2.sum_amount
        
        );
/*
Важно!
Обратите внимание, что в группировку включен столбецgenre_id, который используется в HAVING. Это связано с тем, что в HAVING можно использовать либо столбцы, перечисленные в GROUP BY, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца genre_idне влияет на группировку, так как между названием жанра и его id - взаимно-однозначное соответствие.
Название столбца genre_id задается с указанием имени таблицы (genre.genre_id), так как этот столбец входит в структуру двух таблиц book и genre.  Для этого запроса можно было бы указать и book.genre_id, так как эти таблицы связаны внутренним соединением INNER JOIN и имеют одинаковые значения в полях genre.genre_id и book.genre_id.
*/

select b.title, a.name_author, g.name_genre, b.price, b.amount
from book as b 
    inner join author as a on a.author_id = b.author_id
    inner join 
    (select qq1.genre_id
     from
        (select b.genre_id, sum(b.amount) as sum_amount
        from book as b
         group by b.genre_id
         ) as qq1 inner join
        
         (select b.genre_id, sum(b.amount) as sum_amount
         from book as b
         group by b.genre_id
         order by sum_amount desc
         limit 1
         ) as qq2 on qq1.sum_amount = qq2.sum_amount       
   
    ) as tt on tt.genre_id = b.genre_id
    inner join genre as g on g.genre_id = tt.genre_id
order by title;


/* ниже представлено решение, более переработанное */
select b.title, a.name_author, g.name_genre, b.price, b.amount
from book as b 
    inner join author as a on a.author_id = b.author_id
    inner join 
   (
        select b.genre_id
        from book as b
        group by b.genre_id
        having sum(b.amount) =  
            (select sum(b.amount) as sum_amount
            from book as b
            group by b.genre_id
            order by sum_amount desc
            limit 1
            )  (следущий уровень вот этот select внутри join написать при помощи аналитической функции partition by)          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ) as tt on tt.genre_id = b.genre_id
    inner join genre as g on g.genre_id = tt.genre_id
order by title;







(Ещё бы qq2 переделать на having внутри запроса qq1 вместо join qq1 и qq2)
------------------------------------------------------------------------------------------------------               
				Операция соединение, использование USING()
  При описании соединения таблиц с помощью join в некоторых случаях вместо on и следующего за ним условия можно использовать оператор using()
using позволяет указать набор столбцов, которые есть в обех объединяемых таблицах. Если база данных хорошо спрокетирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), тогда можно использовать предложение using для реализации операции join
  При этом после select, при использовании столбцов из using(), необязательно указывать, из какой именно таблицы берется столбец.

/*пример: вывести название книг, фамилии и id их авторов
вариант с ON */
select b.title, a.name_author, a.author_id /* явно указать таблицу - обязательно */
from author as a inner join book as b on a.author_id = b.author_id;

/* вариант с using*/
select b.title, a.name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно */
from author as a inner join book as b using(author_id);

/* Запись условия соединения с ON является более общим случаем, так как
        1. позволяет задавать соединения не только по одноименным полям
        2. позволяет использовать произвольное условие на соединение таблиц, при этом в условие может            включаться произвольное выражение, например, можно указать связь двух таблиц по двум и                более столбцам.
Пример
В таблице supply занесена информация о книгах, поступивших на склад
Если в таблицах supply и book есть одинаковые книги, вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковыми названиями

важно. В данном примере для соединения book и supply использовать using нельзя, так как:
        1. в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author,                  столбец name_author, а в таблице supply фамилии занесены в столбец author
        2. для озднозначной индетификации книги нужно указать, что совпадают не только названия, но и            авторы книг*/
select b.title, a.name_author
from book as b 
        inner join author as a using(author_id)
        inner join supply as s on b.title = s.title and a.name_author = s.author;

/* Задание 
Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах supply и book,  столбцы назвать Название, Автор  и Количество.
*/
select b.title, a.name_author, (sum(s.amount) + sum(b.amount)) as Количество
from book as b 
    inner join author as a using(author_id)
    inner join supply as s on s.title = b.title and s.author = a.name_author and b.price = s.price
group by b.title, a.name_author;


------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------  
				2.3 ЗАПРОСЫ КОРРЕКТИРОВКИ, СОЕДИНЕНИЯ ТАБЛИЦ
				Запросы на обновление, связанные таблицы

/*update таблица_1 
... join таблица_2 on выражение
    ...
set ...
where ...;
*/
/*
ПРИМЕР
    Для книг, которые уже есть на складе (в таблице book) по той же цене, что и в поставке (supply), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.
    Этот запрос должен отобрать строки из таблиц bookи supply такие, что у них совпадают и автор, и название книги. Но в таблице supply фамилия автора записана не числом (id), а текстом. Следовательно, чтобы выполнить сравнение по фамилии автора нужно "подтянуть" таблицу author,  которая связана с bookпо столбцу author_id.  И в логическом выражении, описывающем соединение таблиц, можно будет использовать столбцы из таблиц book, authorи supply. 
    Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор AND. Например, для следующих таблиц логическую связь по названию и автору:
*/
/*update book as b 
    inner join author as a on a.author_id = b.author_id
    inner join supply as s on b.title = s.title and s.author = a.name_author
set b.amount = b.amount + s.amount, s.amount = 0
where b.price = s.price;
select * from book;
select * from supply;
*/
/*
Задание
Для книг, которые уже есть на складе (в таблице book), но по другой цене, чем в поставках (supply), необходимо в таблице book увеличить количествно на значение, указанное в поставке, и пересчитать цену. А в таблице supply обнулить количество этих книг. 
Формула для расчета цены: price = (p1*k1 + p2*k2) / (k1 + k2)
где  p1, p2 - цена книги в таблицах book и supply;
     k1, k2 - количество книг в таблицах book и supply.
*/
update book as b 
    inner join author as a on a.author_id = b.author_id
    inner join supply as s on b.title = s.title and s.author = a.name_author
        set b.price = (b.price * b.amount + s.price * s.amount)/(b.amount + s.amount), 
        b.amount = b.amount + s.amount,
        s.amount = 0       
where b.price <> s.price;
select * from book;
select * from supply;
------------------------------------------------------------------------------------------------------               
				Запросы на добавление, связанные таблицы
Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:

insert into author (name_author)
select s.author
from author as a right join supply as s on a.name_author = s.author
where a.name_author is null;
select * from supply;

------------------------------------------------------------------------------------------------------               
			ШАГ 4 ИЗ 9

Добавить новые книги из таблицы supply в таблицу book на основе сформированного выше запроса. Затем вывести для просмотра таблицу book.

insert into book(title, author_id, genre_id, price, amount)
select s.title, a.author_id, null, s.price, s.amount
from author as a inner join supply as s on a.name_author = s.author
where s.amount <> 0;

select * from book;
------------------------------------------------------------------------------------------------------               
				ШАГ 5 ИЗ 9
			Запрос на обновление, вложенные запросы
 Занести для книги «Стихотворения и поэмы» Лермонтова жанр «Поэзия», а для книги «Остров сокровищ» Стивенсона - «Приключения». (Использовать два запроса).

update book as b
set b.genre_id = 
    (
     select g.genre_id
     from genre as g
     where g.name_genre = 'Поэзия'
    )
where b.book_id = 10;

update book as b
set b.genre_id = 
    (
     select g.genre_id
     from genre as g
     where g.name_genre = 'Приключения'
    )
where b.book_id = 11;

select * from book;

------------------------------------------------------------------------------------------------------               
				ШАГ 6 ИЗ 9
			Каскадное удаление записей связанных таблиц
/*ПРИМЕР
Удалим из таблицы author всех авторов, фамилия которых начинается на «Д», а из таблицы book  - все книги этих авторов.

delete from author as a
where a.name_author like 'Д%';
select * from author;
select * from book;  */

/* ЗАДАНИЕ 
Удалить всех авторов и все их книги, общее количество книг которых меньше 20.
подзапросом вытащу нужные мне id-шники авторов, а затем в where напишу, чтобы id-шник был в этом списке. Плевое дело! */
delete from author as a
where a.author_id in (select b.author_id
       from book as b
       group by b.author_id
       having sum(b.amount) < 20);
select * from author;
select * from book;


------------------------------------------------------------------------------------------------------               
				ШАГ 7 ИЗ 9
		Удаление записей главной таблицы с сохранением записей в зависимой

/*
    При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.
    Если задано SET NULL, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение NULL. (При этом в столбце внешнего ключа должно быть допустимо значение NULL)
В таблице book эта опция установлена на поле genre_id.
Пример
    Удалим из таблицы genre все  жанры, название которых заканчиваются на «я» , а в таблице book  -  для этих жанров установим значение Null.

delete from genre as g
where g.name_genre like '%я';
select * from genre;
select * from book; */

/* ЗАДАНИЕ
 Удалить все жанры, к которым относится меньше 4-х книг. В таблице book для этих жанров установить значение Null. */
delete from genre as g
where g.genre_id in 
    (select b.genre_id 
    from book as b
    group by b.genre_id
    having count(b.amount) < 4
    );
select * from book;
------------------------------------------------------------------------------------------------------               
				ШАГ 8 ИЗ 9
		Удаление записей, использование связанных таблиц
При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц. В этом случае синтаксис запроса имеет вид:
DELETE FROM таблица_1
USING 
    таблица_1 
    INNER JOIN таблица_2 ON ...
WHERE ...

/*Удалить всех авторов из таблицы author, у которых есть книги, количество экземпляров которых меньше 3. Из таблицы book удалить все книги этих авторов.
delete from author
using author inner join book on author.author_id = book.author_id
where book.amount < 3;
select * from author;
select * from book;
*/

Удалить всех авторов, которые пишут в жанре "Поэзия". Из таблицы book удалить все книги этих авторов. В запросе для отбора авторов использовать полное название жанра, а не его id.

(при помощи вложенного запроса в where)
delete from author
using author inner join book on author.author_id = book.author_id
where book.genre_id = (select g.genre_id from genre as g where g.name_genre = 'Поэзия');
select * from author;
select * from book;

(при помощи двух join-ов)
delete from author
using author inner join book on book.author_id = author.author_id
inner join genre on genre.genre_id = book.genre_id
where genre.name_genre = 'Поэзия';
select * from author;
select * from book;
------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------                                2.4 База данных «Интернет-магазин книг», запросы на выборку 
				ШАГ 5 ИЗ 16
			Запросы на основе трех и более связанных таблиц
/*Вывести фамилии всех клиентов, которые заказали книгу Булгакова «Мастер и Маргарита».*/
/*select distinct cl.name_client, bb.amount
from client as cl
    inner join buy on cl.client_id = buy.client_id
    inner join buy_book as bb on bb.buy_id = buy.buy_id
    inner join book as b on bb.book_id = b.book_id
where title = 'Мастер и Маргарита' and b.author_id = 1;
*/
/*Вывести все заказы Баранова Павла (id заказа, какие книги, по какой цене и в каком количестве он заказал) в отсортированном по номеру заказа и названиям книг виде.*/
select buy.buy_id, b.title, b.price, bb.amount
from client as cl 
    inner join buy on cl.client_id = buy.client_id
    inner join buy_book as bb on buy.buy_id = bb.buy_id
    inner join book as b on bb.book_id = b.book_id
where cl.name_client = 'Баранов Павел'
order by buy.buy_id, b.title;

------------------------------------------------------------------------------------------------------               				ШАГ 6 ИЗ 16
Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать, в каком количестве заказов фигурирует каждая книга).  Вывести фамилию и инициалы автора, название книги, последний столбец назвать Количество. Результат отсортировать сначала  по фамилиям авторов, а потом по названиям книг.

select a.name_author, b.title, coalesce(tt.Количество, 0) as Количество
from book as b 
    left join 
        (select bb.book_id, count(bb.amount) as Количество
        from buy_book as bb
        group by bb.book_id
        ) as tt on tt.book_id = b.book_id
    left join author as a on b.author_id = a.author_id
order by a.name_author, b.title
------------------------------------------------------------------------------------------------------               
				ШАГ 7 ИЗ 16
Вывести города, в которых живут клиенты, оформлявшие заказы в интернет-магазине. Указать количество заказов в каждый город, этот столбец назвать Количество. Информацию вывести по убыванию количества заказов, а затем в алфавитном порядке по названию городов.

select c.name_city, count(buy.buy_id) as Количество
from city as c 
    inner join client as cl on c.city_id = cl.city_id
    inner join buy on buy.client_id = cl.client_id
group by c.name_city
order by 2 desc, c.name_city
------------------------------------------------------------------------------------------------------               				ШАГ 8 ИЗ 16
Вывести номера всех оплаченных заказов и даты, когда они были оплачены.

select bs.buy_id, bs.date_step_end
from buy_step as bs inner join step as s on bs.step_id = s.step_id
where bs.date_step_end is not null and s.name_step = 'Оплата';


------------------------------------------------------------------------------------------------------               				ШАГ 9 ИЗ 16

    Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде. Последний столбец назвать Стоимость.

select buy.buy_id, cl.name_client, sum(bb.amount * b.price) as Стоимость
from buy 
    inner join client   as cl on buy.client_id = cl.client_id
    inner join buy_book as bb on buy.buy_id = bb.buy_id
    inner join book     as b  on b.book_id = bb.book_id
group by buy.buy_id, cl.client_id 
order by buy.buy_id;

(То же самое, только реализованное при помощи using)
select buy.buy_id, cl.name_client, sum(bb.amount * b.price) as Стоимость
from buy 
    inner join client   as cl using(client_id)
    inner join buy_book as bb using(buy_id)
    inner join book     as b  using(book_id)
group by buy.buy_id, cl.client_id 
order by buy.buy_id;
------------------------------------------------------------------------------------------------------               				ШАГ 10 ИЗ 16
Вывести номера заказов (buy_id) и названия этапов,  на которых они в данный момент находятся. Если заказ доставлен –  информацию о нем не выводить. Информацию отсортировать по возрастанию buy_id.
Пояснение -  текущим  считается тот этап, для которого заполнена дата начала этапа и не заполнена дата его окончания.

select bs.buy_id, step.name_step
from buy_step as bs inner join step using(step_id)
where bs.date_step_beg is not null and bs.date_step_end is null
order by bs.buy_id
------------------------------------------------------------------------------------------------------               				ШАГ 11 из 16
В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город (рассматривается только этап Транспортировка). Для тех заказов, которые прошли этап транспортировки, вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, в противном случае вывести 0. В результат включить номер заказа (buy_id), а также вычисляемые столбцы Количество_дней и Опоздание. Информацию вывести в отсортированном по номеру заказа виде.
Пояснение
    Для вычисления поля «Опоздание» используйте функцию if(), а для вычисления разности дат – функцию DATEDIFF().
    Если доставка еще не осуществлена, то поле date_step_end  для этапа Транспортировка - пусто.

select buy.buy_id, datediff(date_step_end, date_step_beg) as Количество_дней, if(datediff(date_step_end, date_step_beg) > days_delivery, (datediff(date_step_end, date_step_beg) - days_delivery), 0) as Опоздание
from city
    inner join client using(city_id)
    inner join buy using(client_id)
    inner join buy_step as bs using(buy_id)
where bs.step_id = 3 and bs.date_step_end is not null
order by buy.buy_id;


------------------------------------------------------------------------------------------------------               				ШАГ 12 из 16
Задание
Выбрать всех клиентов, которые заказывали книги Достоевского, информацию вывести в отсортированном по алфавиту виде. В решении используйте фамилию автора, а не его id.

select distinct cl.name_client 
from client as cl
    inner join buy using(client_id)
    inner join buy_book as bs using(buy_id)
    inner join book as b using(book_id)
    inner join author as a using(author_id)
where a.name_author = 'Достоевский Ф.М.'
order by 1

------------------------------------------------------------------------------------------------------               				ШАГ 13 из 16
Вывести жанр (или жанры), в котором было заказано больше всего экземпляров книг, указать это количество. Последний столбец назвать Количество.
	Пояснение
Использовать вложенный запрос для вычисления максимального значения экземпляров книг.  Рекомендуется запрос реализовывать по шагам.

select genre.name_genre, sum(bb.amount) as Количество
from genre 
    inner join book using(genre_id)
    inner join buy_book as bb using(book_id)
group by genre.name_genre
having sum(bb.amount) = 
        (/*вычислим жанр, в котором больше всего покупок*/
	select max(tt.sum_amount)
        from (/*посчитаем количество заказанных книг по жанрам*/
                select b.genre_id, sum(bb.amount) as sum_amount
                from book as b inner join buy_book as bb using(book_id)
                group by b.genre_id
             ) tt
        );
------------------------------------------------------------------------------------------------------               				ШАГ 14 из 16
			https://stepik.org/lesson/308891/step/14?unit=291017
Оператор UNION

Оператор UNION используется для объединения двух и более SQL запросов, его синтаксис:

SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...

или

SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
/*Вывести всех клиентов, которые делали заказы или в этом, или в предыдущем году.
select cl.name_client
from buy_archive as ba
    inner join client as cl using(client_id)
union all
select cl.name_client
from buy
    inner join client as cl using(client_id);

select cl.name_client
from buy_archive as ba
    inner join client as cl using(client_id)
union
select cl.name_client
from buy
    inner join client as cl using(client_id);


Вывести информацию об оплаченных заказах за предыдущий и текущий год, информацию 
отсортировать по  client_id.

select ba.buy_id, ba.client_id, ba.book_id, ba.date_payment, ba.amount, ba.price
from buy_archive as ba;
--union all
select buy.buy_id, client_id, bb.book_id, bs.date_step_end, bb.amount, b.price
from book as b
     inner join buy_book bb using(book_id)
     inner join buy using(buy_id)
     inner join buy_step bs using(buy_id)
     inner join step using(step_id) 
where bs.date_step_end is not null and step.name_step = 'Оплата'
order by client_id;
*/	
В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020

	Задание
Сравнить ежемесячную выручку от продажи книг за текущий и предыдущий годы. Для этого вывести год, месяц, сумму выручки в отсортированном сначала по возрастанию месяцев, затем по возрастанию лет виде. Название столбцов: Год, Месяц, Сумма.

В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020

select year(ba.date_payment) as Год, monthname(ba.date_payment) as Месяц, sum(ba.price * ba.amount) as Сумма
from buy_archive as ba
group by year(ba.date_payment), monthname(ba.date_payment)
union
select year(bs.date_step_end), monthname(bs.date_step_end), sum(bb.amount * b.price)
from buy_step as bs 
    inner join step using(step_id)
    inner join buy using(buy_id)
    inner join buy_book as bb using(buy_id)
    inner join book as b using(book_id)
where bs.date_step_end is not null and name_step = 'Оплата'
group by year(bs.date_step_end), monthname(bs.date_step_end)
order by Месяц, Год;
------------------------------------------------------------------------------------------------------               				ШАГ 15 из 16
/*
Пример
Вывести клиентов, которые делали покупки в прошлом году, но не делали в этом. А также новых клиентов, которые делали заказы только в текущем году. Информацию отсортировать по возрастанию лет.

Шаг 1. Отберем клиентов прошлого года, указав дату самого раннего заказа, а также клиентов этого года, указав для них самую раннюю дату оплаты заказа.
Запрос
SELECT name_client, MIN(date_payment) AS first_payment
FROM 
    buy_archive 
    INNER JOIN client USING(client_id)
GROUP BY  name_client
UNION
SELECT name_client, MIN(date_step_end)
FROM 
    buy 
    INNER JOIN client USING(client_id)
    INNER JOIN buy_step USING(buy_id)
GROUP BY name_client

Результат:

+-----------------+---------------+
| name_client     | first_payment |
+-----------------+---------------+
| Абрамова Катя   | 2019-02-10    |
| Баранов Павел   | 2019-02-21    |
| Яковлева Галина | 2019-03-05    |
| Абрамова Катя   | 2020-03-05    |
| Баранов Павел   | 2020-02-20    |
| Семенонов Иван  | 2020-02-28    |
+-----------------+---------------+

Как видно из таблицы, некоторые клиенты делали покупки как в прошлом, так и в этом году. Они встречаются в таблице 2 раза.

Шаг 2. Оставим только тех клиентов, которые встречаются в полученной таблице один раз, для этого используем предыдущий запрос как вложенный.

Запрос:

SELECT name_client, MIN(YEAR(first_payment)) AS Год
FROM
  (
   SELECT name_client, MIN(date_payment) AS first_payment
   FROM 
       buy_archive 
       INNER JOIN client USING(client_id)
   GROUP BY  name_client
   UNION
   SELECT name_client, MIN(date_step_end)
   FROM 
       buy 
       INNER JOIN client USING(client_id)
       INNER JOIN buy_step USING (buy_id)
   GROUP BY name_client
  ) query_in
GROUP BY name_client
HAVING COUNT(*) = 1
ORDER BY 2
*/



    Для каждой отдельной книги необходимо вывести информацию о количестве проданных экземпляров и их стоимости за 2020 и 2019 год . Вычисляемые столбцы назвать Количество и Сумма. Информацию отсортировать по убыванию стоимости.

select t.title, sum(t.Количество) as Количество, sum(t.Сумма) as Сумма
from 
(
select b.title, sum(ba.amount) as Количество, sum(ba.price * ba.amount) as Сумма
from  buy_archive as ba
    inner join book b using(book_id)
group by b.title
union all
select b.title, sum(bb.amount), sum(bb.amount * b.price)
from buy_book bb 
    inner join book b using(book_id)
    inner join buy_step bs using(buy_id)
where bs.date_step_end is not null and bs.step_id = 1
group by b.title
) t
group by t.title
order by 3 desc;

------------------------------------------------------------------------------------------------------    					2.1            
В запросах на добавление можно одновременно заносить и константы, и данные из других таблиц. Для этого в той части запроса INSERT , где задается запрос на выборку, в качестве полей для вставки указываются не только поля других таблиц, но и  константы:

INSERT INTO ... 
SELECT 'Попов Илья', city_id, 'popov@test'
FROM city
WHERE ...;

Задание
Включить нового человека в таблицу с клиентами. Его имя Попов Илья, его email popov@test, проживает он в Москве.

insert into client (name_client, city_id, email)
select 'Попов Илья', city_id, 'popov@test'
from city
where city_id = 1;
select * from client;
-----------------------------------------------------------------------------------------------------2.2

 Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».
insert into buy(buy_description, client_id)
select 'Связаться со мной по поводу доставки', client_id
from client
where name_client = 'Попов Илья';
select * from buy;


------------------------------------------------------------------------------------------------------               				2.3.
 Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».

insert into buy (buy_description, client_id)
select 'Связаться со мной по вопросу доставки', client_id
from client
where name_client = 'Попов Илья';
select * from buy;
------------------------------------------------------------------------------------------------------               				2.4
Задание
В таблицу buy_book добавить заказ с номером 5. Этот заказ должен содержать книгу Пастернака «Лирика» в количестве двух экземпляров и книгу Булгакова «Белая гвардия» в одном экземпляре.

insert into buy_book (buy_id, book_id, amount)
select 5, b.book_id, 2
from book as b
where b.title = 'Лирика' and author_id = (
    select b.author_id
    from book as b inner join author as a using(author_id)
    where a.name_author = 'Пастернак Б.Л.' and b.title = 'Лирика');
    
insert into buy_book (buy_id, book_id, amount)
select 5, b.book_id, 1
from book as b
where b.title = 'Белая гвардия' and author_id = (
    select b.author_id
    from book as b inner join author as a using(author_id)
    where a.name_author = 'Булгаков М.А.' and b.title = 'Белая гвардия'); 


------------------------------------------------------------------------------------------------------               				2.5

Задание
Количество тех книг на складе, которые были включены в заказ с номером 5, уменьшить на то количество, которое в заказе с номером 5  указано.

update book b, buy_book bb
set b.amount = b.amount - bb.amount
where buy_id = 5 and b.book_id = bb.book_id;

select * from book;
------------------------------------------------------------------------------------------------------               				2.6
Задание
Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену, количество заказанных книг и  стоимость. Последний столбец назвать Стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.

create table buy_pay as
select b.title, a.name_author, b.price, bb.amount, sum(b.price * bb.amount) as Стоимость
from book as b
    inner join author as a using(author_id)
    inner join buy_book as bb using(book_id)
where buy_id = 5
group by b.title, a.name_author, b.price, bb.amount
order by b.title;

select * from buy_pay;
------------------------------------------------------------------------------------------------------               				2.7
Задание
Создать общий счет (таблицу buy_pay) на оплату заказа с номером 5. Куда включить номер заказа, количество книг в заказе (название столбца Количество) и его общую стоимость (название столбца Итого). Для решения используйте ОДИН запрос.

create table buy_pay as
select bb.buy_id, sum(bb.amount) as Количество, sum(bb.amount * b.price) as Итого
from buy_book as bb
    inner join book as b using(book_id)
where bb.buy_id = 5    
group by bb.buy_id;

select * from buy_pay;

------------------------------------------------------------------------------------------------------               				2.8
Задание
В таблицу buy_step для заказа с номером 5 включить все этапы из таблицы step, которые должен пройти этот заказ. В столбцы date_step_beg и date_step_end всех записей занести Null.

insert into buy_step (buy_id, step_id, date_step_beg, date_step_end)
select 5, step_id, null, null
from step;
select * from buy_step;

------------------------------------------------------------------------------------------------------               				2.9
Задание
В таблицу buy_step занести дату 12.04.2020 выставления счета на оплату заказа с номером 5.

Правильнее было бы занести не конкретную, а текущую дату. Это можно сделать с помощью функции Now(). Но при этом в разные дни будут вставляться разная дата, и задание нельзя будет проверить, поэтому  вставим дату 12.04.2020.

update buy_step
set date_step_beg = '2020.04.12'
where buy_id = 5 and step_id = (select step_id from step where name_step = 'Оплата');
select * from buy_step
where buy_id = 5;
------------------------------------------------------------------------------------------------------               				2.10
Задание

Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»), задав в столбце date_step_beg для этого этапа ту же дату.

Реализовать два запроса для завершения этапа и начала следующего. Они должны быть записаны в общем виде, чтобы его можно было применять для любых этапов, изменив только текущий этап. Для примера пусть это будет этап «Оплата»

update buy_step 
set date_step_end = '2020.04.13'
where buy_id = 5 and step_id = (select step_id from step where name_step = 'Оплата');

update buy_step 
set date_step_beg = '2020.04.13'
where buy_id = 5 and step_id = (select step_id from step where name_step = 'Упаковка');

select * from buy_step
where buy_id = 5;

------------------------------------------------------------------------------------------------------               				3.1-3.2 База данных «Тестирование», запросы на выборку
Задание
Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. Информацию вывести по убыванию результатов тестирования.

select st.name_student, a.date_attempt, a.result
from attempt as a 
    inner join student as st using(student_id)
    inner join subject as sb using(subject_id)
where sb.name_subject = 'Основы баз данных'
order by result desc;

------------------------------------------------------------------------------------------------------               				3.3 

Задание
Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, который округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы теста, который занесен в столбец result.  В результат включить название дисциплины, а также вычисляемые столбцы Количество и Среднее. Информацию вывести по убыванию средних результатов.

select sb.name_subject, count(a.subject_id) as Количество, round(sum(a.result) / count(a.result), 2) as Среднее
from subject as sb
    left join attempt as a using(subject_id)
group by sb.name_subject
order by 3 desc;


------------------------------------------------------------------------------------------------------               				3.4 

Задание
Вывести студентов (различных студентов), имеющих максимальные результаты попыток. Информацию отсортировать в алфавитном порядке по фамилии студента.
Максимальный результат не обязательно будет 100%, поэтому явно это значение в запросе не задавать.

select st.name_student, a.result
from attempt as a
    inner join student as st using(student_id)
where a.result = (
    select max(a.result)
    from attempt as a)
order by st.name_student;


------------------------------------------------------------------------------------------------------               3.5
					 
Задание
Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и последней попыткой. В результат включить фамилию и имя студента, название дисциплины и вычисляемый столбец Интервал. Информацию вывести по возрастанию разницы. Студентов, сделавших одну попытку по дисциплине, не учитывать. 

select st.name_student, sb.name_subject, datediff(max(a.date_attempt), min(date_attempt)) as Интервал
from attempt as a
    inner join student as st using(student_id)
    inner join subject as sb using(subject_id)
group by st.name_student, sb.name_subject
having count(a.date_attempt) > 1
order by datediff(max(a.date_attempt), min(date_attempt));

------------------------------------------------------------------------------------------------------          
		3.6

Задание
Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем). Вывести дисциплину и количество уникальных студентов (столбец назвать Количество), которые по ней проходили тестирование . Информацию отсортировать сначала по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, тестирование по которым студенты еще не проходили, в этом случае указать количество студентов 0.

select sb.name_subject, count(distinct a.student_id) as Количество
from subject as sb
    left join attempt as a using(subject_id)
group by sb.name_subject
order by 2 desc, 1;    

------------------------------------------------------------------------------------------------------          		3.7
Задание
Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных». В результат включите столбцы question_id и name_question.    

select q.question_id, q.name_question
from question as q
where q.subject_id = (select s.subject_id from subject as s where s.name_subject = 'Основы баз данных')
order by 1
limit 3;
------------------------------------------------------------------------------------------------------          		3.8
Задание
Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  (значение attempt_id для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет (вывести Верно или Неверно). В результат включить вопрос, ответ и вычисляемый столбец  Результат.
    
select q.name_question, a.name_answer, if(a.is_correct = 1, 'Верно', 'Неверно') as Результат
from question as q     
    inner join testing as t using(question_id)
    inner join answer as a using(answer_id)
where q.subject_id = (select sb.subject_id
       from subject as sb
       where sb.name_subject = 'Основы SQL')
       and t.attempt_id = 7;

------------------------------------------------------------------------------------------------------          
		3.9
Задание
Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. Вывести фамилию студента, название предмета, дату и результат. Последний столбец назвать Результат. Информацию отсортировать сначала по фамилии студента, потом по убыванию даты попытки.

select st.name_student, sb.name_subject, att.date_attempt, round(sum(is_correct)*100/3, 2) Результат
from answer as a
    inner join testing using(answer_id)
    inner join attempt att using(attempt_id)
    inner join subject sb using(subject_id)
    inner join student st using(student_id)
group by 1, 2, 3
order by 1, 3 desc

или вот так

SELECT name_student,
       name_subject,
       date_attempt,
       ROUND((SUM(answer.is_correct) / COUNT(question.question_id) * 100), 2) AS Результат
  FROM attempt
       JOIN student  USING (student_id)
       JOIN testing  USING (attempt_id)
       JOIN subject  USING (subject_id)
       JOIN question USING (question_id)
       JOIN answer   USING (answer_id)
 GROUP BY name_student,
       name_subject,
       date_attempt
 ORDER BY name_student ASC,
       date_attempt DESC


------------------------------------------------------------------------------------------------------         
	3.1.10
Задание 
Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству ответов, значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, и общее количество ответов на этот вопрос. В результат включить название дисциплины, вопросы по ней (столбец назвать Вопрос), а также два вычисляемых столбца Всего_ответов и Успешность. Информацию отсортировать сначала по названию дисциплины, потом по убыванию успешности, а потом по тексту вопроса в алфавитном порядке.
 
select sb.name_subject, 
       CONCAT(LEFT(q.name_question, 30), '...') as Вопрос,
       count(t.answer_id) as Всего_ответов,
       round(100 * sum(a.is_correct) / count(t.answer_id), 2) as Успешность
from subject sb
     inner join question q on sb.subject_id = q.subject_id
     inner join testing t on q.question_id = t.question_id
     left join answer a on t.answer_id = a.answer_id
group by sb.name_subject, q.name_question
order by sb.name_subject, 4 desc, 2


------------------------------------------------------------------------------------------------------          
	3.2.2
Задание
В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». Установить текущую дату в качестве даты выполнения попытки.

insert into attempt (student_id, subject_id, date_attempt, result)
select (select distinct student_id from attempt 
       left join student using(student_id)
       where name_student = 'Баранов Павел'),
       (select distinct subject_id from attempt 
       left join subject using(subject_id)
       where name_subject = 'Основы баз данных'),
       now(),
       null
from attempt
    inner join subject using(subject_id)
    inner join student using(student_id)
where name_subject = 'Основы баз данных' and name_student = 'Баранов Павел';
select * from attempt;
------------------------------------------------------------------------------------------------------          	3.2.3  
Задание 
Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, занесенный в таблицу attempt последним, и добавить их в таблицу testing. id последней попытки получить как максимальное значение id из таблицы attempt.

insert into testing (attempt_id, question_id)
select a.attempt_id, q.question_id
from question q
    inner join attempt a using(subject_id)
where a.attempt_id = (select max(attempt_id) from attempt)
order by rand()
limit 3;
select * from testing
------------------------------------------------------------------------------------------------------          
	3.2.4
Задание
Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.
Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8. В таблицу testing занесены следующие ответы пользователя:

update attempt
set result = (select (round(100 * sum(a.is_correct) / count(a.is_correct)))
    from answer a
        inner join testing t using(answer_id)
    where t.attempt_id = 8)
where attempt_id = 8;
select * from attempt;
                   
------------------------------------------------------------------------------------------------------         
	3.2.5
Задание
Удалить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим попыткам вопросы из таблицы testing, которая создавалась следующим запросом:

delete from attempt
where date_attempt < '2020-05-01';
select * from attempt;
select * from testing;
------------------------------------------------------------------------------------------------------               
			3.3.2
Задание
Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в отсортированном по фамилиям виде.

select e.name_enrollee
from enrollee e 
    inner join program_enrollee using(enrollee_id)
    inner join program p using(program_id)
where p.name_program = 'Мехатроника и робототехника'
order by 1;

------------------------------------------------------------------------------------------------------               3.3.3
Задание
Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать в обратном алфавитном порядке.

select name_program
from program p
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on ps.subject_id = s.subject_id
where name_subject = 'Информатика'
order by 1 desc;

------------------------------------------------------------------------------------------------------          
		3.3.4
Задание
Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов по предмету ЕГЭ. Вычисляемые столбцы назвать Количество, Максимум, Минимум, Среднее. Информацию отсортировать по названию предмета в алфавитном порядке, среднее значение округлить до одного знака после запятой.

select s.name_subject,
       count(*) as Количество,
       max(es.result) as Максимум,
       min(es.result) as Минимум,
       round(avg(es.result),1) as Среднее
from enrollee_subject es
    inner join subject s on s.subject_id = es.subject_id
group by 1
order by 1;
------------------------------------------------------------------------------------------------------          
		3.3.5
Задание
Вывести образовательные программы, для которых минимальный балл ЕГЭ по каждому предмету больше или равен 40 баллам. Программы вывести в отсортированном по алфавиту виде.

select p.name_program
from program_subject ps
    inner join program p on p.program_id = ps.program_id
group by p.name_program
having min(ps.min_result) >= 40
order by 1;

------------------------------------------------------------------------------------------------------          
		3.3.6
Задание
Вывести образовательные программы, которые имеют самый большой план набора,  вместе с этой величиной.

select name_program, plan
from program
where plan = (select max(plan) from program)
------------------------------------------------------------------------------------------------------          
		3.3.7
Задание
Посчитать, сколько дополнительных баллов получит каждый абитуриент. Столбец с дополнительными баллами назвать Бонус. Информацию вывести в отсортированном по фамилиям виде.

select e.name_enrollee, if(sum(a.bonus) is null, 0, sum(a.bonus)) as Бонус
from enrollee e
    left join enrollee_achievement ea on e.enrollee_id = ea.enrollee_id
    left join achievement a on ea.achievement_id = a.achievement_id
group by e.name_enrollee
order by 1;
------------------------------------------------------------------------------------------------------          
		3.3.8.
Задание
Выведите сколько человек подало заявление на каждую образовательную программу и конкурс на нее (число поданных заявлений деленное на количество мест по плану), округленный до 2-х знаков после запятой. В запросе вывести название факультета, к которому относится образовательная программа, название образовательной программы, план набора абитуриентов на образовательную программу (plan), количество поданных заявлений (Количество) и Конкурс. Информацию отсортировать в порядке убывания конкурса.

select d.name_department, p.name_program, p.plan, count(p.name_program) as Количество, round(count(p.name_program)/ (p.plan), 2) as Конкурс 
from program_enrollee pe
    inner join program p using(program_id)
    inner join department d using(department_id )
group by d.name_department, p.name_program, p.plan
order by 5 desc;
------------------------------------------------------------------------------------------------------          		3.3.9
Задание
Вывести образовательные программы, на которые для поступления необходимы предмет «Информатика» и «Математика» в отсортированном по названию программ виде.
     
select p.name_program
from (select program_id, name_program,department_id, plan
from program p 
    inner join program_subject using(program_id)
    inner join subject s using(subject_id)
where s.name_subject = 'Информатика') p 
    left join program_subject ps on p.program_id = ps.program_id
    left join subject s on s.subject_id = ps.subject_id      
where s.name_subject = 'Математика'
order by 1;

------------------------------------------------------------------------------------------------------          
		3.3.10
Задание
Посчитать количество баллов каждого абитуриента на каждую образовательную программу, на которую он подал заявление, по результатам ЕГЭ. В результат включить название образовательной программы, фамилию и имя абитуриента, а также столбец с суммой баллов, который назвать itog. Информацию вывести в отсортированном сначала по образовательной программе, а потом по убыванию суммы баллов виде.

select p.name_program, e.name_enrollee, sum(es.result) as itog
from enrollee e
    inner join program_enrollee pe on pe.enrollee_id = e.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on es.subject_id = s.subject_id and e.enrollee_id = es.enrollee_id 
group by p.name_program, e.name_enrollee
order by p.name_program, 3 desc;
------------------------------------------------------------------------------------------------------          
		3.3.11
Задание
	Вывести название образовательной программы и фамилию тех абитуриентов, которые подавали документы на эту образовательную программу, но не могут быть зачислены на нее. Эти абитуриенты имеют результат по одному или нескольким предметам ЕГЭ, необходимым для поступления на эту образовательную программу, меньше минимального балла. Информацию вывести в отсортированном сначала по программам, а потом по фамилиям абитуриентов виде.
	Например, Баранов Павел по «Физике» набрал 41 балл, а  для образовательной программы «Прикладная механика» минимальный балл по этому предмету определен в 45 баллов. Следовательно, абитуриент на данную программу не может поступить.

# Ну и зачем ты тут использовал группировку. Если прочитать условие, то становится понятно, что группировка тут не нужна, а нужно только условие (результат тестирования меньше минимального для зачисления)
/* ЭТО НЕПРАВИЛЬНЫЙ ВАРИАНТ ОТВЕТА
select p.name_program, e.name_enrollee , sum(es.result), sum(ps.min_result)
from enrollee e 
    inner join program_enrollee pe on e.enrollee_id = pe.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on s.subject_id = es.subject_id and e.enrollee_id = es.enrollee_id
where es.result >= ps.min_result
group by p.name_program, e.name_enrollee
having (sum(ps.min_result) / sum(es.result)) <= 1
*/
ВОТ ЭТОТ НИЖЕ ПРАВИЛЬНЫЙ.

select p.name_program, e.name_enrollee # (, es.result, ps.min_result # sum(es.result), sum(ps.min_result) )
from enrollee e 
    inner join program_enrollee pe on e.enrollee_id = pe.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on s.subject_id = es.subject_id and e.enrollee_id = es.enrollee_id
where es.result <= ps.min_result
order by p.name_program, e.name_enrollee
------------------------------------------------------------------------------------------------------          


				3.4.2
Задание
Создать вспомогательную таблицу applicant,  куда включить id образовательной программы, id абитуриента, сумму баллов абитуриентов (столбец itog) в отсортированном сначала по id образовательной программы, а потом по убыванию суммы баллов виде (использовать запрос из предыдущего урока).

create table applicant as
select p.program_id, e.enrollee_id, sum(es.result) as itog
from enrollee e
    inner join program_enrollee pe on pe.enrollee_id = e.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on es.subject_id = s.subject_id and e.enrollee_id = es.enrollee_id 
group by p.program_id, e.enrollee_id
order by p.program_id, sum(es.result) desc;

select * from applicant
------------------------------------------------------------------------------------------------------          
		3.4.3
Задание
Из таблицы applicant, созданной на предыдущем шаге, удалить записи, если абитуриент на выбранную образовательную программу не набрал минимального балла хотя бы по одному предмету (использовать запрос из https://stepik.org/lesson/310418/step/11?unit=292724 предыдущего урока).

delete from applicant
using applicant
inner join (
select p.program_id, e.enrollee_id
from enrollee e 
    inner join program_enrollee pe on e.enrollee_id = pe.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on s.subject_id = es.subject_id and e.enrollee_id = es.enrollee_id
where es.result <= ps.min_result
order by p.program_id, e.enrollee_id
) tt on tt.program_id = applicant.program_id and tt.enrollee_id = applicant.enrollee_id;
select * from applicant;
------------------------------------------------------------------------------------------------------          
		3.4.4
Задание
Повысить итоговые баллы абитуриентов в таблице applicant на значения дополнительных баллов (использовать запрос из предыдущего урока https://stepik.org/lesson/310418/step/7?unit=292724).

update applicant
    inner join (
select e.enrollee_id, if(sum(a.bonus) is null, 0, sum(a.bonus)) as Бонус
from enrollee e
    left join enrollee_achievement ea on e.enrollee_id = ea.enrollee_id
    left join achievement a on ea.achievement_id = a.achievement_id
group by e.enrollee_id
order by 1
) tt on tt.enrollee_id = applicant.enrollee_id
set itog = itog + Бонус;
select * from applicant;
------------------------------------------------------------------------------------------------------          
		3.4.5
Задание
Поскольку при добавлении дополнительных баллов, абитуриенты по каждой образовательной программе могут следовать не в порядке убывания суммарных баллов, необходимо создать новую таблицу applicant_order на основе таблицы applicant. При создании таблицы данные нужно отсортировать сначала по id образовательной программы, потом по убыванию итогового балла. А таблицу applicant, которая была создана как вспомогательная, необходимо удалить.

create table applicant_order
select a.program_id, a.enrollee_id, a.itog 
from applicant a
order by 1, 3 desc;

drop table applicant;
select * from applicant_order;
------------------------------------------------------------------------------------------------------          
		3.4.6

Для отбора рекомендованных к зачислению студентов можно разработать различные алгоритмы. Мы реализуем несколько SQL запросов. В первом запросе вставим в таблицу applicant_order новый столбец для последовательной нумерации строк. 
Для изменения структуры таблицы используется оператор ALTER TABLE. С его помощью можно вставить новый столбец, удалить существующий, переименовать столбец и пр.
Для вставки нового столбца используется SQL запросы:
ALTER TABLE таблица ADD имя_столбца тип; - вставляет столбец после последнего
ALTER TABLE таблица ADD имя_столбца тип FIRST; - вставляет столбец перед первым
ALTER TABLE таблица ADD имя_столбца тип AFTER имя_столбца_1; - вставляет столбец после укзанного столбца
Для удаления столбца используется SQL запросы:
ALTER TABLE таблица DROP COLUMN имя_столбца; - удаляет столбец с заданным именем
ALTER TABLE таблица DROP имя_столбца; - ключевое слово COLUMN не обязательно указывать
ALTER TABLE таблица DROP имя_столбца,
                    DROP имя_столбца_1; - удаляет два столбца
Для переименования столбца используется  запрос (тип данных указывать обязательно):
ALTER TABLE таблица CHANGE имя_столбца новое_имя_столбца ТИП ДАННЫХ;
Для изменения типа  столбца используется запрос (два раза указывать имя столбца обязательно): 
ALTER TABLE таблица CHANGE имя_столбца имя_столбца НОВЫЙ_ТИП_ДАННЫХ;

Задание
Включить в таблицу applicant_order новый столбец str_id целого типа , расположить его перед первым.

alter table applicant_order add str_id int first;
select * from applicant_order;

------------------------------------------------------------------------------------------------------          		3.4.7

Задание
Занести в столбец str_id таблицы applicant_order нумерацию абитуриентов, которая начинается с 1 для каждой образовательной программы.     
Пояснение
В запросе на обновление используйте вложенный запрос , в котором нумеруются записи таблицы applicant_order по образовательным программам. В качестве условия соединения таблицы и вложенного запроса после ключевого слова   указать, что id программ в таблице applicant_order и во вложенном запросе совпадают, а также id абитуриентов в таблице applicant_order и во вложенном запросе совпадают. (СПИСАЛ, САМ РЕШИТЬ НЕ СМОГ, СБИЛО В УСЛОВИЯХ ЗАДАЧИ 
, ЧТО НУЖНО СДЕЛАТЬ ВЛОЖЕННЫЙ ЗАПРОС. УЖЕ 2 ПРИМЕРА НЕ СМОГ РЕШИТЬ ИЗ КУРСА И СПИСАЛ. ПЕЧАЛЬКА)

set @row_num := 1;
set @num_pr := 0;
update applicant_order
set str_id = if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1 and @num_pr := @num_pr + 1);
select * from applicant_order;
------------------------------------------------------------------------------------------------------          
		3.4.8
Задание
Создать таблицу student,  в которую включить абитуриентов, которые могут быть рекомендованы к зачислению  в соответствии с планом набора. Информацию отсортировать сначала в алфавитном порядке по названию программ, а потом по убыванию итогового балла.
На каждую образовательную программу может быть зачислено только обозначенное в плане число абитуриентов (например, n). Выбираются первые n абитуриентов, набравших наибольшее количество баллов. В str_id содержится нумерация (отсортированных по сумме баллов абитуриентов), начинающаяся с 1 для каждой образовательной программы. И соответственно, если по плану нужно зачислить n абитуриентов, то выбираются все абитуриенты, порядковый номер которых в str_id меньше или равен n.
То есть в таблицу на каждую образовательную программу включить абитуриентов, значение str_id которых в таблице applicant_order меньше или равно плану

create table student as
select p.name_program, e.name_enrollee, ao.itog
from enrollee e 
    inner join applicant_order ao on ao.enrollee_id = e.enrollee_id
    inner join program p on p.program_id = ao.program_id
where ao.str_id <= p.plan
order by 1, 3 desc;
select * from student;
------------------------------------------------------------------------------------------------------          
		3.5.2
Задание
Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:
    в поле Модуль указать номер модуля и его название через пробел;
    в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через пробел;
    в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага (step_position) через точку и название шага через пробел.
Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию номеров модулей, порядковых номеров уроков и порядковых номеров шагов.

select concat(left(concat(m.module_id, ' ', m.module_name), 16), '...') as Модуль,
       concat(left(concat(m.module_id, '.', l.lesson_position, ' ', l.lesson_name), 16), '...') as Урок,
       concat(m.module_id, '.', l.lesson_position, '.', s.step_position, ' ', s.step_name) as Шаг
from step s 
    inner join lesson l on l.lesson_id = s.lesson_id
    inner join module m on m.module_id = l.module_id
where s.step_name like '%ложенн%'
order by 1, 2, 3;



------------------------------------------------------------------------------------------------------          
		3.5.3
/*
Еще одна возможность улучшить навигацию по курсу - это реализация поиска шагов по ключевым словам. Для этого необходимо создать таблицу с терминами keyword, а затем связать ее с таблицей step через вспомогательную таблицу step_keyword. Каждая запись этой таблицы - это id шага и id встречающегося на этом шаге ключевого слова.
Задание
Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в step_keyword строку с id шага и id ключевого слова. 
REGEXP_INSTR(string, pat) делает то же самое, что и INSTR(string1, string2), только вторым аргументом можно подставить регулярное выражение. Символ конца слова надо набирать как \\b, если что.*/

insert into step_keyword
select s.step_id, k.keyword_id
from step s, keyword k
where regexp_instr(s.step_name , concat('\\b', k.keyword_name, '\\b'));
select * from step_keyword;


------------------------------------------------------------------------------------------------------          
		3.5.4
Задание
Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG одновременно. Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать Шаг. Информацию отсортировать по первому столбцу в алфавитном порядке.

select concat(m.module_id, '.', l.lesson_position, '.', if(s.step_position < 10, concat(0,  s.step_position), s.step_position), ' ', s.step_name) as Шаг 
from module m
    inner join lesson l on m.module_id = l.module_id
    inner join step s on l.lesson_id = s.lesson_id
    inner join step_keyword sk on s.step_id = sk.step_id
    inner join keyword k on k.keyword_id = sk.keyword_id
where k.keyword_name = 'max' or k.keyword_name = 'avg'
group by 1
having count(*) = 2 
order by 1;
------------------------------------------------------------------------------------------------------          		3.5.5     
Задание
Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.

/*
Отнести каждого студента к группе,  в зависимости от пройденных заданий:

select tt.student_name, tt.rate,
    case
        when rate <= 10 then 'I'
        when rate <= 15 then 'II'
        when rate <= 27 then 'III'
        else 'IV'
    end as Группа
from (
select t.student_name, count(*) as rate
from 
    (
     select student_name, step_id
     from student
         inner join step_student using(student_id)
     where result = 'correct'
     group by student_name, step_id
     order by 1
     ) t
group by student_name
order by 2
    ) tt;*/
/*
Задание
Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.*/

select ttt.group_rate as Группа
       ,case when ttt.group_rate = 'I' then 'от 0 до 10'
            when ttt.group_rate = 'II' then 'от 11 до 15'
            when ttt.group_rate = 'III' then 'от 16 до 27'
            else 'больше 27'
            end as Интервал
       ,count(ttt.group_rate) as Количество
from 
(
select tt.student_name, tt.rate, 
    case 
        when tt.rate <= 10 then 'I'
        when tt.rate <= 15 then 'II'
        when tt.rate <= 27 then 'III'
        else 'IV'
    end as group_rate    
from
(select t.student_name, count(*) as rate
from (
    select s.student_name, ss.step_id
    from student s 
        inner join step_student ss using(student_id)
    where ss.result = 'correct'
    order by s.student_name
    ) t
group by t.student_name
order by 2
) tt
) ttt
group by ttt.group_rate
order by ttt.group_rate;
------------------------------------------------------------------------------------------------------         
		3.5.6
Задание
Исправить запрос примера так: для шагов, которые  не имеют неверных ответов,  указать 100 как процент успешных попыток, если же шаг не имеет верных ответов, указать 0. Информацию отсортировать сначала по возрастанию успешности, а затем по названию шага в алфавитном порядке.

with get_count_correct (st_n_c, count_correct)
  as (
      select s.step_name, count(*)
      from step s 
          inner join step_student ss using(step_id)
      where result = 'correct'
      group by s.step_name
     ),
    get_count_wrong (st_n_w, count_wrong)
  as (
      select s.step_name, count(*)
      from step s
          inner join step_student ss using(step_id)
      where result = 'wrong'
      group by s.step_name
     )
select st_n_c as Шаг, if(round(count_correct / (count_correct + count_wrong) * 100) is null, 100,              round(count_correct / (count_correct + count_wrong) * 100)) as Успешность
  from get_count_correct
       left join get_count_wrong on st_n_c = st_n_w
 union
select st_n_w as Шаг,
       if(round(count_correct / (count_correct + count_wrong) * 100) is null, 0, round(count_correct           / (count_correct + count_wrong) * 100)) as Успешность
  from get_count_correct
       right join get_count_wrong on st_n_c = st_n_w
 order by 2, 1;

/*или (НЕ МОЕ РЕШЕНИЕ)
SELECT step_name AS Шаг,
       ROUND(AVG(IF(result = 'correct', 1, 0)) * 100) AS Успешность
  FROM step
       inner join step_student USING(step_id)
 GROUP BY step_id
 ORDER BY Успешность, Шаг; */
------------------------------------------------------------------------------------------------------          		3.5.7
Задание
Вычислить прогресс пользователей по курсу. Прогресс вычисляется как отношение верно пройденных шагов к общему количеству шагов в процентах, округленное до целого. В нашей базе данные о решениях занесены не для всех шагов, поэтому общее количество шагов определить как количество различных шагов в таблице step_student.
Тем пользователям, которые прошли все шаги (прогресс = 100%) выдать "Сертификат с отличием". Тем, у кого прогресс больше или равен 80% - "Сертификат". Для остальных записей в столбце Результат задать пустую строку ("").
Информацию отсортировать по убыванию прогресса, затем по имени пользователя в алфавитном порядке.     

select s.student_name as Студент,
       round(100 * count(tt.student_id) / (select count(distinct step_id) from step_student)) as              Прогресс,
       case
           when round(100 * count(tt.student_id) / (select count(distinct step_id) from step_student)) = 100 then 'Сертификат с отличием'
           when round(100 * count(tt.student_id) / (select count(distinct step_id) from step_student))  >= 80 then 'Сертификат'
           else ''
       end as Результат       
from 
(
select distinct step_id, student_id, count(distinct step_id)
from step_student
where result = 'correct'
group by step_id, student_id
order by 1, 2
) tt inner join student s using(student_id)
group by student_id
order by 2 desc, 1;
------------------------------------------------------------------------------------------------------          
		3.5.8

/*
Синтаксис оконных функций, оператор OVER, ORDERE BY
название_функции(выражение)
    OVER (
          partition by столбец_1, столбец_2, ... - это окно
          ORDER BY  ... - сортировка
          rows between - границы окна
          ...
    ) # причем все разделы over являются не обязательными, но обязательно нужно указать либо окно, либо сортировку.

На данном шаге рассмотрим самый простой синтаксис оконного выражения:

название_функции(выражение)
    over (
          order by...
    )
Пример
Вычислить, сколько шагов прошел пользователь. Ранжировать пользователей по убыванию результатов.*/
select student_name, count(distinct step_id) as Количество,
       row_number() over(order by count(distinct step_id) desc) as Номер
from student inner join step_student using(student_id)
where result = 'correct'
group by student_name;

/*В этом запросе после того, как были выбраны все студенты, посчитаны их шаги с правильными ответами, с помощью оконной функции была выполнена сортировка по количеству верных шагов (count(DISTINCT step_id))  и пронумерованы строки (функция ROW_NUMBER()).
Дополнительно ранжируем студентов.*/
select student_name, count(distinct step_id) as Количество,
    row_number() over (order by count(distinct step_id) desc) as Номер,
    rank() over (order by count(distinct step_id) desc) as Ранг,
    dense_rank() over (order by count(distinct step_id) desc) as Рейтинг
from step_student 
    inner join student using(student_id)
where result = 'correct'
group by student_name;
/*С помощью функции RANK() и DENSE_RANK() все студенты, имеющие 30  верно пройденных шагов, получили ранг 2 и  рейтинг 2. Студентам с 29 балами присвоен ранг 16 и  рейтинг 3.

Пример
Для каждого студента указать, на сколько меньше он прошел шагов, чем идущий перед ним по рейтингу студент
*/
select student_name, count(distinct step_id) as Количество,
    lag(count(distinct step_id))
    over (order by count(distinct step_id) desc) - count(distinct step_id) as Разница
from student inner join step_student using(student_id)
where result = 'correct'
group by student_name;

/*Так как у первой записи нет предыдущей - значение разницы null. Заменим ее на 0 с помощью функции:
ifnull(выражение, результат)
которая возвращает результат, если выражение равно null, и само выражение в противном случае*/
select student_name, count(distinct step_id) as Количество,
    ifnull(lag(count(distinct step_id))
          over (order by count(distinct step_id) desc) - count(distinct step_id),
          0) as Разница
from student inner join step_student using(student_id)
where result = 'correct'
group by student_name;


Задание
Для студента с именем student_61 вывести все его попытки: название шага, результат и дату отправки попытки (submission_time). Информацию отсортировать по дате отправки попытки и указать, сколько минут прошло между отправкой соседних попыток. Название шага ограничить 20 символами и добавить "...". Столбцы назвать Студент, Шаг, Результат, Дата_отправки, Разница.
Пояснение
 1. Время в таблице step_student представлено в формате  Unix-время , в котором хранится количество секунд, прошедших с 1 января 1970 года. Для перевода к привычному виду DATE используется формула:
1970-01-01 + time_unix / 86400
В SQL для перевода удобно использовать функцию  FROM_UNIXTIME( ).
Например:
FROM_UNIXTIME(1598291490) =  2020-08-24 17:51:30
2. Для перевода количества секунд во временной формат используется функция SEC_TO_TIME(),например:
SEC_TO_TIME(288) = 0:04:48

select s.student_name as Студент,
       concat(left(step.step_name, 20),'...') as Шаг, # Вывожу только первые 20 символов с названия шага, а после приклеиваю многоточие
       ss.result as Результат,
       from_unixtime(ss.submission_time) as Дата_отправки, # перевод к привычному формату видe date (использутеся формула 1970-01-01 + time_unix / 86400, в SQL для перевода удобно использовать функцию from_unixtime())
       sec_to_time(submission_time - ifnull((lag(submission_time) over(order by submission_time)), submission_time)) as Разница
  from step_student ss
       inner join step using(step_id)
       inner join student s using(student_id)
 where student_name = 'student_61'
 order by 4, 5;

либо можно вот так: сразу прописать в lag()
select s.student_name as Студент,
       concat(left(step.step_name, 20),'...') as Шаг, # Вывожу только первые 20 символов с названия шага, а после приклеиваю многоточие
       ss.result as Результат,
       from_unixtime(ss.submission_time) as Дата_отправки, # перевод к привычному формату видe date (использутеся формула 1970-01-01 + time_unix / 86400, в SQL для перевода удобно использовать функцию from_unixtime())
       sec_to_time(submission_time - (lag(submission_time, 1, submission_time) over(order by submission_time))) as Разница
  from step_student ss
       inner join step using(step_id)
       inner join student s using(student_id)
 where student_name = 'student_61'
 order by 4, 5;
------------------------------------------------------------------------------------------------------          
		3.5.9
Задание
Посчитать среднее время, за которое пользователи проходят урок по следующему алгоритму:
    для каждого пользователя вычислить время прохождения шага как сумму времени, потраченного на каждую попытку (время попытки - это разница между временем отправки задания и временем начала попытки), при этом попытки, которые длились больше 4 часов не учитывать, так как пользователь мог просто оставить задание открытым в браузере, а вернуться к нему на следующий день;
    для каждого студента посчитать общее время, которое он затратил на каждый урок;
    вычислить среднее время выполнения урока в часах, результат округлить до 2-х знаков после запятой;
    вывести информацию по возрастанию времени, пронумеровав строки, для каждого урока указать номер модуля и его позицию в нем.
Столбцы результата назвать Номер, Урок, Среднее_время.

select row_number() over(order by round(avg(t.sum_dt) / 3600, 2)) as Номер,
       concat(l.module_id, '.', l.lesson_position, ' ', t.lesson_name) as Урок,
       
       round(avg(t.sum_dt) / 3600, 2) as Среднее_время
from (
select l.lesson_name, ss.student_id, sum(ss.submission_time - ss.attempt_time) as sum_dt
from step_student ss
    inner join step s using(step_id)
    inner join lesson l using(lesson_id)
where (ss.submission_time - ss.attempt_time) <= (3600 * 4) and l.lesson_name in
(select lesson_name 
  from lesson
  where lesson_name in ('Запросы на выборку, соединение таблиц', 'Выборка данных', 'База данных "Интернет-магазин книг", запросы на выборку'))
group by ss.student_id, l.lesson_name

) t
    inner join lesson l on t.lesson_name = l.lesson_name
group by t.lesson_name, l.module_id, l.lesson_position;

более удачное мое решение
select row_number() 
       over(order by sum(ss.submission_time - ss.attempt_time) / count(distinct ss.student_id)) as Номер,
       concat(l.module_id, '.', l.lesson_position, '.', l.lesson_name) as Урок,
       round(sum(ss.submission_time - ss.attempt_time) / count(distinct ss.student_id) / 3600, 2) as Среднее_время
  from step_student ss
       inner join step s on s.step_id = ss.step_id
       inner join lesson l on l.lesson_id = s.lesson_id
 where ss.submission_time - ss.attempt_time <= 4 * 3600
 group by Урок;
------------------------------------------------------------------------------------------------------          
		3.5.10
Задание
Вычислить рейтинг каждого студента относительно студента, прошедшего наибольшее количество шагов в модуле (вычисляется как отношение количества пройденных студентом шагов к максимальному количеству пройденных шагов, умноженное на 100). Вывести номер модуля, имя студента, количество пройденных им шагов и относительный рейтинг. Относительный рейтинг округлить до одного знака после запятой. Столбцы назвать Модуль, Студент, Пройдено_шагов и Относительный_рейтинг  соответственно. Информацию отсортировать сначала по возрастанию номера модуля, потом по убыванию относительного рейтинга и, наконец, по имени студента в алфавитном порядке.

WITH get_rate_lesson(mod_id, stud, rate) 
AS
(
   SELECT module_id, student_name, count(DISTINCT step_id)
     FROM student INNER JOIN step_student USING(student_id)
                INNER JOIN step USING (step_id)
                INNER JOIN lesson USING (lesson_id)
    WHERE result = "correct"
    GROUP BY module_id, student_name
)
SELECT mod_id AS Модуль, stud AS Студент, rate AS Пройдено_шагов, 
       round(100 * rate / max(rate) over(partition by mod_id ), 1) as Относительный_рейтинг
FROM get_rate_lesson
order by mod_id, 4 desc, stud;
------------------------------------------------------------------------------------------------------          
		3.5.11
Задание
Проанализировать, в каком порядке и с каким интервалом пользователь отправлял последнее верно выполненное задание каждого урока. В базе занесены попытки студентов  для трех уроков курса, поэтому анализ проводить только для этих уроков.
Для студентов прошедших как минимум по одному шагу в каждом уроке, найти последний пройденный шаг каждого урока - крайний шаг, и указать:
    имя студента;
    номер урока, состоящий из номера модуля и через точку позиции каждого урока в модуле;
    время отправки  - время подачи решения на проверку;
    разницу во времени отправки между текущим и предыдущим крайним шагом в днях, при этом для первого шага поставить прочерк ("-"), а количество дней округлить до целого в большую сторону.
Столбцы назвать  Студент, Урок,  Макс_время_отправки и Интервал  соответственно. Отсортировать результаты по имени студента в алфавитном порядке, а потом по возрастанию времени отправки.


/* 
1) Найти последнее верно выполненное задание каждого урока (то есть наверное это max(step_id) и создать окно с партицией по module_id). Всего заполненных уроков 3
2) Учитывать только тех студентов, которые прошли хотя бы один шаг из всех трех уроков (для этого создам партицию по студентам, чтобы нумеровал по порядку, в каких уроках у студента есть решение верное (это в with). А затем select ом просто отберу тех студентов, у которых порядковый номер 3, который означает, что у него есть верные решения во всех 3-ёх уроках).
3) В результирующую выборку включить: имя студента (student_name), номер урока (состоящий из модуля урока и через точку позиции каждого урока в модуле)
4) Найти разность дат между текущим и предыдущим крайним шагом в днях, при этом для первого шага поставить прочерк ('-'), а количество дней округлить до целого в большую сторону.
5) Столбцы назвать "Студент", "Урок", "Макс_время_отправки" и "Интервал" соответственно. Отсортировать результаты по имени студента в алфавитном порядке, а потом по возрастанию времни отправки.
*/

with max_solved_step_inlesson(stud, mod_id, max_step, att_time, num) #, row_num
as 
(
    select s.student_name,
           concat(l.module_id, '.', l.lesson_position),
           max(ss.step_id),
           max(ss.submission_time),
           row_number() over(partition by s.student_name) as row_num
      from step_student ss
           inner join student s on s.student_id = ss.student_id
           inner join step on ss.step_id = step.step_id
           inner join lesson l on l.lesson_id = step.lesson_id
     where ss.result = 'correct'
     group by s.student_name, l.module_id, l.lesson_position
     order by 1
)
select mssi.stud as Студент,
       mssi.mod_id as Урок,
       FROM_UNIXTIME(mssi.att_time) as Макс_время_отправки, 
       ifnull(ceiling((mssi.att_time - lag(mssi.att_time)
       over(partition by mssi.stud order by mssi.stud, mssi.att_time)) / 24 /3600), '-') as Интервал
 from max_solved_step_inlesson as mssi
where mssi.stud in (select mssi2.stud
                    from max_solved_step_inlesson as mssi2
                    where mssi2.num = 3)
------------------------------------------------------------------------------------------------------          		3.5.12
Задание
Для студента с именем student_59 вывести следующую информацию по всем его попыткам:
    информация о шаге: номер модуля, символ '.', позиция урока в модуле, символ '.', позиция шага в модуле;
    порядковый номер попытки для каждого шага - определяется по возрастанию времени отправки попытки;
    результат попытки;
    время попытки (преобразованное к формату времени) - определяется как разность между временем отправки попытки и времени ее начала, в случае если попытка длилась более 1 часа, то время попытки заменить на среднее время всех попыток пользователя по всем шагам без учета тех, которые длились больше 1 часа;
    относительное время попытки  - определяется как отношение времени попытки (с учетом замены времени попытки) к суммарному времени всех попыток  шага, округленное до двух знаков после запятой  .
Столбцы назвать  Студент,  Шаг, Номер_попытки, Результат, Время_попытки и Относительное_время. Информацию отсортировать сначала по возрастанию id шага, а затем по возрастанию номера попытки (определяется по времени отправки попытки).
Важно. Все вычисления производить в секундах, округлять и переводить во временной формат только для вывода результата.
Фрагмент логической схемы базы данных:     

  /*
1.Вывести все попытки для студента student_59, затем от этой выборки уже вывести следующую информацию   по всем его попыткам:
2.Информация о шаге: номер модуля, символ '.', позиция урока в модуле, символ '.', позиция шага в       модуле; concat(l.module_id, '.', l.lesson_position, '.', step.step_position)
3.Порядковый номер попытки для каждого шага - определяется по возрастанию времени отравки попытки       (сделать row_number() over(order by ss.submission_time))
4.Результат попытки (ss.result)
5.Время попытки (преобразованное к формату даты) - определяется как разность между временем отправки   попытки и времени ее начала, в случае если попытка длилась более 1 часа, то время попытки заменить   на среднее время всех попыток пользователя по всем шагам без учета тех, которые длились больше 1     часа.
6.Относительное время попытки - определяется как отношение времени попытки (с учетом замены времени     попытки) к суммарному времени всех попыток шага, округленное до двух знаков после запятой. 
7.Столбцы назвать "Студент", "Шаг", "Номер_попытки", "Результат", "Время_попытки",                     "Относительное_время",
  Важно. Все вычисления производить в секундах, округлять и переводить во временной формат только для   вывода результата.
*/  
with tt
as (
select ss.step_student_id as ssid,
       ss.step_id, 
       s.student_name,
       ss.attempt_time as a_time,
       ss.submission_time as s_time,
       ss.result,
       concat(l.module_id, '.', l.lesson_position, '.', step.step_position) as mod_les_step,
       l.module_id, l.lesson_position, step.step_position,
       round((select avg(ss.submission_time - ss.attempt_time) from step_student ss inner join student st using(student_id)  where ss.submission_time - ss.attempt_time <= 3600 and st.student_name = 'student_59')) as avg_sum,
       sum(ss.submission_time - ss.attempt_time) over () as sum_dif
  from step_student ss 
       inner join student s on s.student_id = ss.student_id
       inner join step on step.step_id = ss.step_id
       inner join lesson l on l.lesson_id = step.lesson_id
 where student_name = 'student_59'
 order by l.module_id, l.lesson_position, step.step_position  
)
#select * from tt
select tt.student_name as Студент,
       tt.mod_les_step as Шаг,
       #concat(tt.module_id, '.', tt.lesson_position, '.', tt.step_position) as t1
       row_number() over(partition by tt.mod_les_step order by tt.a_time) as Номер_попытки, #order by tt.a_time
       tt.result as Результат,
       sec_to_time(if(tt.s_time - tt.a_time > 3600, tt.avg_sum, tt.s_time - tt.a_time)) as Время_попытки,
       round(100 * if(tt.s_time - tt.a_time > 3600, tt.avg_sum, tt.s_time - tt.a_time) / (sum(if(tt.s_time - tt.a_time > 3600, tt.avg_sum, tt.s_time - tt.a_time)) over (partition by tt.mod_les_step)), 2) as Относительное_время
  from tt
  order by tt.module_id, tt.lesson_position, tt.step_position, 3;
------------------------------------------------------------------------------------------------------               
		3.5.13

Задание
Online курс обучающиеся могут проходить по различным траекториям, проследить за которыми можно по способу решения ими заданий шагов курса. Большинство обучающихся за несколько попыток  получают правильный ответ 
и переходят к следующему шагу. Но есть такие, что остаются на шаге, выполняя несколько верных попыток, или переходят к следующему, оставив нерешенные шаги.
Выделив эти "необычные" действия обучающихся, можно проследить их траекторию работы с курсом и проанализировать задания, для которых эти действия выполнялись, а затем их как-то изменить. 
Для этой цели необходимо выделить группы обучающихся по способу прохождения шагов:
    I группа - это те пользователи, которые после верной попытки решения шага делают неверную (скорее всего для того, чтобы поэкспериментировать или проверить, как работают примеры);
    II группа - это те пользователи, которые делают больше одной верной попытки для одного шага (возможно, улучшают свое решение или пробуют другой вариант);
    III группа - это те пользователи, которые не смогли решить задание какого-то шага (у них все попытки по этому шагу - неверные).
Вывести группу (I, II, III), имя пользователя, количество шагов, которые пользователь выполнил по соответствующему способу. Столбцы назвать Группа, Студент, Количество_шагов. Отсортировать информацию по возрастанию номеров групп, потом по убыванию количества шагов и, наконец, по имени студента в алфавитном порядке.

Пояснение
На основе этого задания я посчитала количество различных обучающихся, относящихся к одной или нескольким группам, выделенным в задании. Получилось, что 22 человека из 64 (34%) проходят курс "нестандартно".  Причем пересечение первой и второй   группы  - 9 челове


with dif_way_solutions as (
select
    ss.step_id,
    s.student_name,
    s.student_id,
    ss.result,
    ss.submission_time,
    lag(ss.result) over(partition by s.student_id, ss.step_id order by s.student_id, ss.step_id, ss.submission_time) lg,
    lead(ss.result) over(partition by s.student_id, ss.step_id) ld
from step_student ss
    inner join student s on s.student_id = ss.student_id
)
select 'I' as Группа, s.student_name as Студент, sum(tt.ct) as Количество_шагов
from (
        select dws1.student_id, count(dws1.result) as ct
        from dif_way_solutions as dws1
        where dws1.result = 'correct' and dws1.ld = 'wrong'
        group by dws1.student_id, dws1.step_id, dws1.submission_time
        order by dws1.student_id, dws1.step_id, dws1.submission_time
    ) tt
    inner join student s on s.student_id = tt.student_id
group by tt.student_id

union all

select 'II' ,t.student_name, count(t.student_name)
  from 
    (
        select dws.student_name, count(dws.step_id) 
          from dif_way_solutions dws
         where result = 'correct'
         group by dws.student_name, dws.step_id
        having count(result) > 1
         order by dws.student_name, dws.step_id
    ) t
group by t.student_name

union all

select 'III', ttt.student_name, count(ttt.student_name)
  from 
    (
        select dws.student_name, dws.step_id, max(if(dws.result = 'correct', 1, 0))
          from dif_way_solutions dws
         group by dws.student_name, dws.step_id
        having max(if(dws.result = 'correct', 1, 0)) < 1
    ) ttt
 group by ttt.student_name
 order by Группа, Количество_шагов desc, Студент;

------------------------------------------------------------------------------------------------------          		4.1.2 
Провести аналитику по трем ценовым категориям (до 600 руб, от 600 руб до 700 руб, свыше 700 руб) и вывести среднюю цену  книги, общую стоимость остатков книг  в этой ценовой позиции и количество позиций. Среднюю цену и стоимость округлить до двух знаков после запятой. Информацию отсортировать по возрастанию нижней границы ценовой категории.
Для реализации этого запроса создадим вспомогательную таблицу stat, в которой будут храниться ценовые категории (первая ценовая категория - цены  больше или равны 0 и меньше 600, вторая - больше или равны 600 и меньше 700 и т.д.)

select beg_range, end_range, round(avg(price), 2) as Средняя_цена, round(sum(amount * price), 2) as Стоимость, count(*) as Количество
from stat 
    inner join book on price >= beg_range and price < end_range
group by beg_range, end_range
order by beg_range;

------------------------------------------------------------------------------------------------------          
		4.1.3
Вывести всю информацию из таблицы book, упорядоченную по возрастанию длины названия книги.
Пояснение.
    Для вычисления длины тестовой строки используется функция length().
    Сортировку можно осуществлять не только по назв

select * from book
order by length(title);
------------------------------------------------------------------------------------------------------          
		4.1.4
Задание
Удалить из таблиц book и supplyкниги, цены которых заканчиваются на 99 копеек. Например, книга с ценой 670.99 должна быть удалена.

delete from book
where price % 1 = 0.99;
delete from supply
where price % 1 = 0.99;

select * from book;
select * from supply;
------------------------------------------------------------------------------------------------------          
		4.1.5
Задание
Снизить цены книг, цена которых больше 600 рублей, на 20%. Вывести информацию о книгах, скидку (столбец sale_20) и цену книги со скидкой (price_sale).  Результаты округлить до двух знаков после запятой. Для тех книг, на которые скидка не действует, в последних двух столбцах вывести символ  "-".  Отсортировать информацию сначала по фамилии автора, а потом по названию книги.

select author, title, price, amount, if(price > 600, round(price * 0.2, 2), '-') as sale_20,
       if(price > 600, round(price * 0.8, 2), '-') as price_sale
from book
order by author, title;

------------------------------------------------------------------------------------------------------          
		4.1.6
Задание
Вывести авторов и суммарную стоимость их книг, если хотя бы одна их книга имеет цену выше средней по складу. Средняя цена рассчитывается как простое среднее, с помощью avg(). Информацию отсортировать по убыванию суммарной стоимости.

select author, sum(price * amount) as Стоимость
from book
where author in (select author from book group by author having max(price) > (select avg(price) from book))
group by author
order by 2 desc;

------------------------------------------------------------------------------------------------------          
		4.1.7
Задание
Вывести автора, название, количество, цену (Розничная_цена). Для тех книг количество которых больше или равно 10, отобразить оптовую скидку 15% (Скидка), округлить до двух знаков после запятой и вывести оптовую цену с учетом скидки -15% (Оптовая_цена). Все атрибуты перевести на русский язык. Отсортировать по автору и названию книги

select b.author as Автор, 
       b.title as Название_книги, 
       b.amount as Количество, 
       b.price as Розничная_цена, 
       if(amount >= 10, 15, 0) as Скидка,
       if(amount >= 10, round(b.price * 0.85, 2), b.price) as Оптовая_цена
from book b
order by author, title;
------------------------------------------------------------------------------------------------------          
		4.1.8
Задание
Вывести авторов, у которых есть книги со стоимостью более 500 и количеством более 1 шт на складе. Учитывать книги только тех авторов, у которых не менее 2-х произведений на складе. Вывести автора, количество различных произведений автора, минимальную цену и количество книг на складе. Информацию отсортировать по фамилии автора в алфавитном порядке.

select author, 
       count(author) as Количество_произведений, 
       min(price) as Минимальная_цена, 
       sum(amount) as Число_книг
from book
where amount > 1
group by author
having max(price) > 500 and count(author) >= 2
order by author
------------------------------------------------------------------------------------------------------          
		4.2.1
Магазин счёл, что классика уже не пользуется популярностью, поэтому необходимо в выборке:
1. Сменить всех авторов на "Донцова Дарья".
2. К названию каждой книги в начале дописать "Евлампия Романова и " ( пробел в конце).
3. Цену поднять на 42% (округлить её до двух знаков после запятой).
4. Отсортировать по убыванию цены.

select 'Донцова Дарья' as author, 
       concat('Евлампия Романова и ', title) as title, 
       round(price * 1.42, 2) as price
  from book
 order by price desc;

------------------------------------------------------------------------------------------------------          
		4.2.2

Задание
Вывести жанр(ы), в котором было заказано меньше всего экземпляров книг, указать это количество. Учитывать только жанры, в которых была заказана хотя бы одна книга.
При реализации в основном запросе не используйте LIMIT, поскольку жанров с минимальным количеством заказанных книг может быть несколько.


with tt as 
(
    select g.name_genre, 
           sum(bb.amount) as sum_amount,
           min(sum(bb.amount)) over () as min_sum_amount
      from buy_book bb
           inner join book b using(book_id)
           inner join genre g using(genre_id)
    group by g.name_genre
)
select tt.name_genre, tt.sum_amount as Количество
from tt
where tt.min_sum_amount = tt.sum_amount;


select g.name_genre, sum(bb.amount) as Количество
from buy_book bb
    inner join book b using(book_id)
    inner join genre g using(genre_id)
group by g.name_genre
having sum(bb.amount) = (select min(t.sum_amount) from (
                         select sum(buy_book.amount) as sum_amount
                         from buy_book 
                             inner join book b using(book_id)
                             inner join genre g using(genre_id)
                         group by genre_id) t);

------------------------------------------------------------------------------------------------------          
		4.2.3
Задание
Создать новую таблицу store, в которую занести данные из таблиц book и supply, при условии, что количество книг будет больше среднего количества книг по двум таблицам; если книга есть в обеих таблицах, то стоимость выбрать большую из двух. Отсортировать данные из таблицы их по имени автора в алфавитном порядке и по убыванию цены. Вывести данные из полученной таблицы.

/*set @start = (select avg(amount)
from 
    (   select * from book
        union all 
        select * from supply
    ) t
             );
create table store as 
select tt.title, b.author, tt.price, tt.sum_amount amount
from 
    (
    select t.title, max(t.price) as price, sum(t.amount) sum_amount
    from 
        (
        select title, author, price, amount
          from book
         union all
        select title, author, price, amount 
        from supply
        ) t
    group by t.title
    having sum(t.amount) > @start
    ) tt
    inner join book b on b.title = tt.title
order by 2, 3 desc;
select * from store;*/

или

create table store as
    with t as (
        select title, author, price, amount from book
        union all
        select title, author, price, amount from supply)
    select t.title, t.author, max(t.price) as price, sum(t.amount) as amount
    from t
    group by title, author
    having amount > (select avg(t.amount) from t)
    order by title, price desc;
select * from store;
------------------------------------------------------------------------------------------------------          
		4.2.4
Задание
Объявить столбец "категории цены" (price_category): <500 - "низкая", 500 - 700 - "средняя", более 700 - "высокая"
Вывести автора, название, категорию, стоимость (цена * количество), исключив из авторов Есенина, из названий "Белую гвардию". Отсортировать по убыванию стоимости и названию (по возрастанию)

with t as (
select
        case 
            when b.price < 500 then 'низкая'
            when b.price between 500 and 700 then 'средняя'
            when b.price > 700 then 'высокая'
            end as price_category
        , b.price
        , b.title
        , b.author
        , b.amount
        , sum(b.price * b.amount) over (partition by b.author, b.title) as cost
  from book b
 where not b.author like 'Есенин%' and not b.title = 'Белая гвардия')        
select t.author, t.title, t.price_category, t.cost 
  from t
 order by 4 desc, t.title;

или

select          
      b.author
    , b.title
    , case 
        when b.price < 500 then 'низкая'
        when b.price between 500 and 700 then 'средняя'
        when b.price > 700 then 'высокая'
        end as price_category
    , b.price * b.amount as cost
  from book b
 where not b.author like 'Есенин%' and not b.title = 'Белая гвардия'
 order by cost desc, b.title
    

------------------------------------------------------------------------------------------------------          
		4.2.5
Задание
Для нечетного количества книг посчитать разницу максимальной стоимости (цена * количество) и стоимостью всех экземпляров конкретной книги. Отсортировать по этой разнице по убыванию. Вывести название, автора, количество, разницу с максимальной стоимостью.

set @max_cost = (select max(amount * price) from book);
select b.title, b.author, b.amount, round((@max_cost - b.amount * b.price),2) as Разница_с_макс_стоимостью
from book b
where b.amount % 2 <> 0
order by 4 desc;

------------------------------------------------------------------------------------------------------   
		4.2.6
Задание
Магазин решил быстрее распродать остатки книг, цена которых выше 600, а также прописать условия доставки. Создать запрос на выборку, в котором:
    Столбцы назовите Наименование, Цена и  Стоимость доставки.
    Отберите все книги, цена которых выше 600.
    Если остаток по отдельной книге меньше или равен 5, то стоимость доставки будет 500 рублей, если больше 5, то доставка будет бесплатной (вместо стоимости доставки вставить Бесплатно).
    Отсортируйте значения по убыванию цены книг.

select title as Наименование, price as Цена, if(amount <= 5, 500, 'Бесплатно') as Стоимость_доставки
from book
where price > 600
order by price desc

------------------------------------------------------------------------------------------------------   
		4.2.7
Задание
На распродаже размер скидки устанавливается в зависимости от количества экземпляров книги в магазине и от цены книги: для книг в остатке не менее 5 шт скидка 50%, тогда как для книг в остатке менее 5 шт скидка устанавливается в зависимости от цены (на книги не дешевле 700 руб скидка 20%, на остальные 10%). Два последних столбца назвать Скидка и Цена_со_скидкой.  Последний столбец округлить до двух знаков после запятой.

select t.author, t.title, t.amount, t.price, concat(t.dd, '%') Скидка, round(t.price * (1-t.dd/100),2) as Цена_со_скидкой
from
(select author,
       title, 
       amount, 
       price, 
       case when amount >= 5 then 50
            when amount < 5 then if(price > 700, 20, 10)
       end as dd       
from book
) t
------------------------------------------------------------------------------------------------------   
		4.2.8
Задание
Определить стоимость доставки:
- для книг c ценой 500 и менее, установить в размере 99.99
- при количестве книг на складе менее 5, а ценой выше 500, установить в размере 149.99
- для остальных случаев доставка должна быть бесплатной
Определить новую стоимость для книг:
- для книг, совокупной стоимостью более 5000, добавить 20% к стоимости за экземпляр
- для остальных случаев снизить стоимость одного экземпляра на 20%
Настроить фильтр при выборке:
- только позиции творчества авторов: Булгаков и Есенин, при количестве экземпляров на складе: от 3 до 14 включительно.
Сортировку выполнить:
- по имени автора в порядке возрастания
- затем по названию в порядке убывания
- по стоимости доставки (от меньшей к большей)
В таблице должны быть отображены данные:
- автора
- название
- количество
- цену, как real_price
- новую цену, как new_price (округлить до двух знаков после запятой)
- стоимость доставки, как delivery_price 

select author, 
       title, 
       amount,
       price as real_price, 
       round(if(price * amount > 5000, price * 1.2, price * 0.8),2) as new_price, 
       if(price <= 500, 99.99, if(amount < 5 and price > 500, 149.99, 0)) as delivery_price
from book
where author in ('Булгаков М.А.', 'Есенин С.А.') and amount between 3 and 14;
------------------------------------------------------------------------------------------------------   

		4.3.1
Задание
Вывести авторов и названия книг и их цену в двух столбцах - рубли и копейки.  Информацию отсортировать по убыванию копеек. 

select author, title, price div 1 Рубли, round(100*(price%1)) Копейки
from book
order by 4 desc;
------------------------------------------------------------------------------------------------------   
		4.3.2
Задание
В связи с повышенным спросом на классическую литературу школьниками в формате "А есть то же самое, но покороче, чтобы читать поменьше?" была выпущена серия "Графоман и. Краткое содержание".
В выборке:
- к имени автора добавить "Графоман и ";
- к названию книги дописать ". Краткое содержание.";
- цену на новый опус установить 40% от цены оригинала, но не более 250. (Если 40% больше 250, то цена должна быть 250);
- в зависимости от остатка на складе вывести "Спрос": до 3 (включительно) - высокий, до 10 (включительно) - средний, иначе низкий;
- добавить колонку "Наличие" в зависимости от количества: 1-2 шт - очень мало, 3-14 - в наличии, 15 и больше - много;
- отсортировать по цене по возрастанию, затем по Спросу от высокого к низкому, а затем по названию книги в алфавитном порядке

select concat('Графоман и ', author) Автор,
       concat(title, '. Краткое содержание.') Название,
       if(price * 0.4 > 250, 250, price * 0.4) Цена,
       if(amount > 0 and amount <= 3, 'высокий', if(amount > 4 and amount <=10, 'средний', 'низкий')) Спрос,
       if(amount <= 2, 'очень мало', if(amount <= 14, 'в наличии', 'много')) Наличие
from book
order by 3, amount, 2
------------------------------------------------------------------------------------------------------   
		4.3.3
Задание
Для клиентов у которых сумма заказов выше средней по суммам заказов клиентов (общей стоимости всех заказов клиентов), вывести имя, общую сумму всех заказов, количество заказов, количество заказанных книг. Этим клиентам мы предложим специальную программу лояльности! Информацию отсортировать по имени клиентов ( в алфавитном порядке).

select c.name_client, sum(bb.amount * b.price) Общая_сумма_заказов, count(distinct bb.buy_id) Заказов_всего, sum(bb.amount) Книг_всего
from buy_book bb
    inner join buy using(buy_id)
    inner join client c using(client_id)
    inner join book b using(book_id)
group by c.name_client
having sum(bb.amount * b.price) > (select avg(ccc) from (
                                   select sum(b.price * bb.amount) ccc
                                   from buy_book bb
                                       inner join book b using(book_id)
                                    group by bb.buy_id) t)
order by 1;

------------------------------------------------------------------------------------------------------   
		4.3.4
Задание
Составить рейтинг книг в зависимости от того, какая книга принесет больше всего выручки (в процентах), при условии продажи всех книг. Рейтинг отсортировать по убыванию выручки. Выручка в процентах вычисляется как стоимость всех экземпляров книги деленное на суммарную стоимость всех экземпляров книг на складе и умноженное на 100, полученный результат округлить до двух знаков после запятой.
Судя по результату, магазин хорошо вложился в Стихи Есенина

select author, title, price, amount, 
       round(100 * (price * amount) / (select sum(price * amount) from book), 2) as income_percent
from book
order by 5 desc;

------------------------------------------------------------------------------------------------------   
		4.3.5
Задание
Для каждого автора из таблицы author вывести количество книг, написанных им в каждом жанре.
Вывести: ФИО автора, жанр, количество.
Отсортировать: по фамилии, затем - по убыванию количества написанных книг, а затем в алфавитном порядке по названию жанра.
Важно! Реализовать задание одним запросом на выборку.

select a.name_author, g.name_genre, count(b.amount) as Количество
from author a cross join genre g
    left join book b on (a.author_id = b.author_id) and (g.genre_id = b.genre_id)
group by a.author_id, g.genre_id
order by a.name_author, 3 desc, g.name_genre;

------------------------------------------------------------------------------------------------------   
		4.3.6
Задание
Акция "Купи книгу от 500 руб. и получи подарок".
Вывести автора, название книги и цену. Выбрать книги с ценой 500 рублей и выше, отсортировать информацию в алфавитном порядке по автору и названию книги. Добавить столбец Подарок,  в котором вывести, какой подарок получает покупатель: если куплена книга от 500 рублей до 600 рублей (включительно), то подарок - ручка, от 600 до 700 (включительно) - детская раскраска, выше 700 - гороскоп.

select author Автор, title Название_книги, price Цена, if(price > 500 and price <= 600, 'ручка', if(price > 600 and price <= 700, 'детская раскраска', 'гороскоп')) as Подарок
from book
where price > 500
order by author, title;



------------------------------------------------------------------------------------------------------   
		4.3.7
Задание
При анализе остатков книг на складе было решено дополнительно заказать книги авторов, у которых суммарное число экземпляров книг меньше 10. В таблице должны быть отображены авторы, наименьшее и наибольшее количество их книг.

select author Автор, min(amount) Наименьшее_кол_во, max(amount) Наибольшее_кол_во
from book
group by author
having sum(amount) < 10


------------------------------------------------------------------------------------------------------   
		4.3.8
Задание
В последний заказ (таблица buy_book) клиента Баранов Павел добавить по одному экземпляру всех книг Достоевского, которые есть в таблице book.

set @m:= (select max(buy_id)
          from buy_book 
              join buy using(buy_id) 
              join client using(client_id)
          where name_client = 'Баранов Павел');
insert into buy_book(buy_id, book_id, amount)
select @m as buy_id, book_id,1 as amount
from author join book
using(author_id)
where name_author like 'Достоевский%';
select * from buy_book;
------------------------------------------------------------------------------------------------------   
		4.4.1
Задание
Найти вопрос, с самой большой успешностью выполнения - "самый легкий" и вопрос, с самой маленькой успешностью выполнения - "самый сложный".  (Подробно про успешность на этом шаге). Вывести предмет, эти два вопроса и указание - самый сложный или самый легкий это вопрос. Сначала вывести самый легкий запроса, потом самый сложный.

with tt as (
select sb.name_subject, 
       q.name_question as quest,
       count(t.answer_id) as Всего_ответов,
       round(100 * sum(a.is_correct) / count(t.answer_id), 2) as sun
from subject sb
     inner join question q on sb.subject_id = q.subject_id
     inner join testing t on q.question_id = t.question_id
     left join answer a on t.answer_id = a.answer_id
group by sb.name_subject, q.name_question
order by 4)
select tt.name_subject, tt.quest as name_question, if(tt.sun = 100, 'самый легкий', 'самый сложный') as Сложность
from tt
where tt.sun = (select min(tt.sun) from tt) or tt.sun = (select max(tt.sun) from tt)
order by tt.sun desc;

------------------------------------------------------------------------------------------------------   
		4.4.2
Задание
Автор - Лариса Фернандес
Для повышения успеваемости, предоставить возможность студентам снова пройти тестирование.
Для студентов, у которых количество попыток меньше 3 и максимальный балл < 70, в таблицу attempt добавить новые попытки по соответствующим предметам с текущей датой.

insert into attempt(student_id, subject_id, date_attempt, result)
select student_id, subject_id, now(), null
from attempt
group by student_id, subject_id
having count(subject_id) < 3 and max(result) < 70;
select * from attempt;