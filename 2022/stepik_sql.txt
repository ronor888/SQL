1.2
--------------------------------------------------

Задание
При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать new_price. Значение округлить до двух знаков после запятой.

/*select title, amount, price,
    round(if(amount<4, (price * 0.5), if(amount<11, price * 0.7, price*0.9)), 2) as sale,
    if(amount < 4, 'скидка 50%', if(amount < 11, 'скидка 30%', 'скидка 10%')) as Ваша_скидка 
from book; */
select author, title, round(if(author = 'Булгаков М.А.', price * 1.1, if(author = 'Есенин С.А.', price * 1.05, price)), 2) as new_price
from book;

----------------------------------------------------------------------------------------------------

Вывести автора, название  и цены тех книг, количество которых меньше 10.

select author, title, price
from book
where amount < 10;

------------------------------------------------------------------------------------------------------               

Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

/*select title, author, price
from book
where author = 'Булгаков М.А.' and price > 600;    
select title, author, price
from book
where (author = 'Есенин С.А.' or author = 'Булгаков М.А.') and price > 600;*/

select title, author, price, amount
from book
where (price < 500 or price > 600) and (price*amount >= 5000);

------------------------------------------------------------------------------------------------------               

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

select title, author
from book
where (price between 540.50 and 800) and (amount in (2,3,5,7));

------------------------------------------------------------------------------------------------------               

Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

select author, title
from book
where amount between 2 and 14
order by author desc, title;

------------------------------------------------------------------------------------------------------               

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

select title, author
  from book
 where title like '_% _%' 
   and (author like '% С._.'
    or author like '% _.С.')
 order by title;
   
------------------------------------------------------------------------------------------------------               -

Придумайте один или несколько запросов к нашей таблице book. Проверьте, правильно ли они работают.

select author
from book
group by author

------------------------------------------------------------------------------------------------------ 
Отобрать различные (уникальные) элементы столбца amount таблицы book.

select distinct amount
from book;

--------------------------------------

Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

select author as Автор, count(author) as Различных_книг, sum(amount) as Количество_экземпляров
from book
group by author;

------------------------------------------------------------------------------------------------------               
			Выборка данных, групповые функции MIN, MAX и AVG

Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.

select author, min(price) as Минимальная_цена, max(price) as Максимальная_цена, avg(price) as Средняя_цена
from book
group by author;

------------------------------------------------------------------------------------------------------               
			Выборка данных c вычислением, групповые функции		
Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой. В запросе для расчета НДС(tax)  и Стоимости без НДС(S_without_tax) использовать следующие формулы: 
tax=((s*k/100)/(1+k/100)
S_without_tax = (s/(1+k/100))

select author, sum(price * amount) as Стоимость
     , round((sum(price * amount) * 0.18/1.18),2) as НДС
     , round(((sum(price * amount))/1.18),2) as Стоимость_без_НДС  
from book
group by author;

------------------------------------------------------------------------------------------------------               
			Вычисления по таблице целиком
Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой. Пояснение. В задании нужно посчитать среднюю цену уникальных книг на складе, а не среднюю цену всех экземпляров книг.

select 
	min(price) as Минимальная_цена
       ,max(price) as Максимальная_цена
       ,round(((sum(price))/count(author)),2) as Средняя_цена
from book
--group by author;
------------------------------------------------------------------------------------------------------               
			Выборка данных по условию, групповые функции
Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.

select
    round(avg(price),2) as Средняя_цена
   ,round(sum(price * amount),2) as Стоимость
from book
where amount between 5 and 14;


------------------------------------------------------------------------------------------------------               
			Выборка данных по условию, групповые функции, WHERE и HAVING

Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.

select author, sum(price * amount) as Стоимость
from book
where title <> 'Идиот' and title <> 'Белая гвардия'
group by author
having sum(price * amount) > 5000  
--так то тут неправильно, должно было быть having round(sum(price * amount) > 5000
order by sum(price * amount) desc

------------------------------------------------------------------------------------------------------               
			Вложенный запрос, возвращающий одно значение
Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

select author, title, price
from book
where price <= (select avg(price) from book) 
order by price desc;

------------------------------------------------------------------------------------------------------               
			Использование вложенного запроса в выражении
Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.

select author, title, price
from book
where (price - (select min(price) from book)) <= 150
order by price
------------------------------------------------------------------------------------------------------               
			Вложенный запрос, оператор IN
Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется. Пояснение в решению: во вложенном запросе отберите те значения столбца amount, количество которых, вычисленное с помощью функции count(), равно 1. 

select author, title, amount
from book
where amount in (select amount
                 from book
                 group by amount
                 having count(amount) = 1
                );
------------------------------------------------------------------------------------------------------               
			Вложенный запрос, операторы ANY и ALL (только во вложенном можно использовать any и all)
Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.

select author, title, price
from book
where price < any(
                    select min(price)
                    from book
                    group by author
                    );

------------------------------------------------------------------------------------------------------               
				Вложенный запрос после SELECT
Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно.

select title, author, amount,(
    (
        select max(amount)
        from book)
        - amount) as Заказ
from book
where ((select max(amount) from book) - amount) > 0;

------------------------------------------------------------------------------------------------------               
Создание таблицы осуществляется с помощью запроса CREATE, подробно рассмотренного в первом уроке модуля.

create table supply(
     supply_id int primary key auto_increment
    ,title varchar(50)
    ,author varchar(30)
    ,price decimal(8,2)
    ,amount int
    );


------------------------------------------------------------------------------------------------------               
				Добавление записей в таблицу
Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:

insert into supply(title, author, price, amount)
values
    ('Лирика', 'Пастернак Б.Л.', 518.99, 2)
   ,('Черный человек', 'Есенин С.А.', 570.20, 6)
   ,('Белая гвардия', 'Булгаков М.А.', 540.50, 7)
   ,('Идиот', 'Достоевский Ф.М.', 360.80, 3);
------------------------------------------------------------------------------------------------------               
				Добавление записей из другой таблицы
Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

insert into book (title, author, price, amount)
select title, author, price, amount
from supply
where author not in ('Булгаков М.А.', 'Достоевский Ф.М.')
------------------------------------------------------------------------------------------------------               
				Добавление записей, вложенные запросы
Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.
(также пришлось убрать автора Есенин С.А, так как в результирущем ответе его не должно было быть)

insert into book (title, author, price, amount)
select title, author, price, amount
from supply
where title not in(
    select title
    from book
    ) and not author = 'Есенин С.А.'; 
select * from book


------------------------------------------------------------------------------------------------------               
				Запросы на обновление
Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы.

update book
set price = 0.9 * price
where amount between 5 and 10;
select * from book;


------------------------------------------------------------------------------------------------------               
				Запросы на обновление нескольких столбцов
В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.

update book
set buy = if(buy >= amount, amount, buy)
   ,price = if(buy > 0, price, 0.9*price);
select * from book;

------------------------------------------------------------------------------------------------------               
				Запросы на обновление нескольких таблиц
В запросах на обновление можно использовать несколько таблиц, но тогда

    для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
    все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
    в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.

Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).

update book, supply
set book.amount = book.amount + supply.amount
   ,book.price = (book.price + supply.price)/2
where book.title = supply.title and book.author = supply.author;

select * from book;

------------------------------------------------------------------------------------------------------               
				Запросы на удаление
Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.

DELETE FROM supply 
WHERE author IN (
        SELECT author 
        FROM book
        group by author
        having sum(amount) > 10
          );

select * from supply;

------------------------------------------------------------------------------------------------------               
				Запросы на создание таблицы
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE.Запрос на создание новой таблицы имеет вид: 
CREATE TABLE имя_таблицы AS
SELECT ...

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

create table ordering as
select author, title, (select round(avg(amount))
                      from book) as amount
from book
where book.amount < (select round(avg(amount))
                    from book);

select * from ordering;

------------------------------------------------------------------------------------------------------               
				1.6
Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

select name, city, per_diem, date_first, date_last
from trip
where name like '%а _._.'
order by date_last desc;

------------------------------------------------------------------------------------------------------               
Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.

select distinct name
from trip
where city = 'Москва'
order by name;

------------------------------------------------------------------------------------------------------               
Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. 

select city, count(city) as Количество 
from trip
group by city
order by city;

------------------------------------------------------------------------------------------------------               
				Оператор LIMIT
Для ограничения вывода записей в SQL используется оператор LIMIT , после которого указывается количество строк.  Результирующая таблица будет иметь количество строк не более указанного после LIMIT. LIMIT размещается после раздела ORDER BY. Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 
Важно. Оператор LIMIT нужно использовать очень осторожно. Например, если бы в таблице trip было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.

------------------------------------------------------------------------------------------------------               
				Оператор LIMIT
Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.

select city, count(city) as Количество
from trip
group by city
order by count(city) desc
limit 2;

------------------------------------------------------------------------------------------------------               
Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

Немного теории
Для вычитания двух дат используется функция DATEDIFF(дата_1, дата_2), результатом которой является количество дней между дата_1 и дата_2. Увеличьте разницу на 1, чтобы включить первый день командировки.

select name, city, (datediff(date_last, date_first) + 1) as Длительность
from trip
where city not in('Москва', 'Санкт-Петербург')
order by 3 desc, city desc

------------------------------------------------------------------------------------------------------               
Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить столбцы name, city, date_first, date_last. Пояснение: используйте вложенный запрос, чтобы найти длительность самой короткой командировки. 

select name, city, date_first, date_last
from trip
where datediff(date_last, date_first) = (select min(datediff(date_last, date_first))
                                         from trip
                                        order by 1);

------------------------------------------------------------------------------------------------------               

Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .
	Немного теории: для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).
Например, MONTH('2020-04-12') = 4.
Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)

select name, city, date_first, date_last
from trip
where month(date_first) = month(date_last)
order by city, name;

------------------------------------------------------------------------------------------------------               
Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Немного теории

    Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название месяца на английском языке для указанной даты. Например, MONTHNAME('2020-04-12')='April'.
    Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после GROUP BYможно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS. Важно отметить, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

select monthname(date_first) as Месяц, count(monthname(date_first)) as Количество
from trip
group by monthname(date_first)
order by count(monthname(date_first)) desc, monthname(date_first) 

------------------------------------------------------------------------------------------------------               
Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem. Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

select name, city, date_first, (per_diem * (datediff(date_last, date_first)+1)) as Сумма
from trip
where month(date_first) = 2 or month(date_first) = 3 
order by name, 4 desc;

------------------------------------------------------------------------------------------------------               
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма.

select name, sum((datediff(date_last, date_first) + 1) * per_diem) as Сумма 
from trip
group by name
having count(name) > 3
order by 2 desc

------------------------------------------------------------------------------------------------------               
https://stepik.org/lesson/305762/step/2?unit=287773
Создать таблицу fine следующей структуры:

create table fine (
                     fine_id INT PRIMARY KEY AUTO_INCREMENT
                    , name varchar(30)
                    , number_plate varchar(6)
                    , violation varchar(50)
                    , sum_fine decimal(8,2)
                    , date_violation date
                    , date_payment date 
                  );

------------------------------------------------------------------------------------------------------               
https://stepik.org/lesson/305762/step/3?unit=287773
В таблицу fine первые 5 строк уже занесены. Добавить в таблицу записи с ключевыми значениями 6, 7, 8.

insert into fine(name, number_plate, violation, sum_fine, date_violation, date_payment)
    values  ('Баранов П.Е.', 'Р523ВТ', 'Превышение скорости(от 40 до 60)', null, '2020-02-14', null)
           ,('Абрамова К.А.', 'О111АВ', 'Проезд на запрещающий сигнал', null, '2020-02-23', null)
           ,('Яковлев Г.Р.', 'Т330ТТ', 'Проезд на запрещающий сигнал', null, '2020-03-03', null);
------------------------------------------------------------------------------------------------------               
			Использование временного имени таблицы (алиаса)


Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.
Таблица traffic_violationсоздана и заполнена.
Важно! Сравнение значения столбца с пустым значением осуществляется с помощью оператора IS NULL.

update fine as f, traffic_violation as tv
set f.sum_fine = tv.sum_fine
where f.sum_fine is null 
and f.violation = tv.violation;

select * from fine;
------------------------------------------------------------------------------------------------------               
				Группировка данных по нескольким столбцам
В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:
((((((((((	Важно! В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не (((((((((       применяются (групповые функции) из SELECT.				)))))))))))))
Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.
Пояснение

Под увеличение  штрафа в два раза подходит водитель «Абрамова К.А.», который на машине с государственным номером «О111АВ» совершил повторное нарушение «Проезд на запрещающий сигнал», а также водитель  «Баранов П.Е.» , который на машине с номером  «Р523ВТ» дважды совершил нарушение «Превышение скорости(от 40 до 60) ».

select f.name, f.number_plate, f.violation  
from fine as f
group by f.name, f.number_plate, f.violation
having count(f.number_plate) = 2 
order by name, number_plate, violation;

------------------------------------------------------------------------------------------------------               
	В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 

    Для всех нарушений, по которым штраф еще не оплачен, (тех, у которых date_payment имеет пустое значение Null), необходимо проверить, является ли данное нарушение для водителя и машины повторным, если да –  увеличить штраф в два раза.
    Если водитель совершил нарушение на другой машине, ему увеличивать штраф не нужно.
    Если несколько повторных нарушений не оплачены, то штраф увеличить для всех.
    Этот запрос реализован на предыдущем шаге.
При реализации можно использовать вложенный запрос как отдельную таблицу, записанную после ключевого слова UPDATE, при этом вложенному запросу необходимо присвоить имя, например query_in:

UPDATE fine, 
    (
     SELECT ...
    ) query_in
SET ...
WHERE указать, что совпадают нарушение, фамилия водителя и номер машины в таблицах fine и вложенном запросе query_in соответственно, а также дата оплаты в таблице fine пуста

Другим способом решения является использование двух запросов: сначала создать временную таблицу, например query_in, в которую включить информацию о тех штрафах, сумму которых нужно увеличить в два раза, а затем уже обновлять информацию в таблице fine:

CREATE TABLE query_in ...;
UPDATE fine, query_in
SET ...
WHERE ...;

После ключевого слова WHERE  указывается условие, при котором нужно обновлять данные. В нашем случае  данные обновляются, если и фамилия, и государственный номер, и нарушение совпадают в таблице fine и в результирующей таблице запроса query_in. Например, для связи по фамилии используется запись fine.name = query_in.name. Также в условии нужно учесть, что данные обновляются только для тех записей, у которых в столбце date_payment пусто.
Важно! Если в запросе используется несколько таблиц или запросов, включающих одинаковые поля, то применяется полное имя столбца, включающего название таблицы через символ «.». Например,  fine.name  и  query_in.name.

create table query_in as (select f.name, f.number_plate, f.violation
                          from fine as f
                          group by f.name, f.number_plate, f.violation
                          having count(*) > 1);
update fine as f, query_in as q
set sum_fine = sum_fine * 2
where f.date_payment is null and
(f.name, f.number_plate, f.violation) = (q.name, q.number_plate, q.violation);
select * from fine;


-- или where f.date_payment is null and f.name = q.name and f.number_plate = q.number_plate and f.violation = --q.violation;
вот это решение ниже, тоже верное

update fine as f, (select f.name, f.number_plate, f.violation
                          from fine as f
                          group by f.name, f.number_plate, f.violation
                          having count(*) > 1) as query_in
set sum_fine = sum_fine * 2
where f.date_payment is null and
(f.name, f.number_plate, f.violation) = (query_in.name, query_in.number_plate, query_in.violation);
select * from fine;

------------------------------------------------------------------------------------------------------               
Задание
Необходимо:
    в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
    уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов, информация о которых занесена в таблицу payment) , если оплата произведена не позднее 20 дней со дня нарушения.

 update fine as f, payment as p
    set f.date_payment = p.date_payment,
        f.sum_fine = if(datediff(p.date_payment, p.date_violation) < 20+1, 0.5 * f.sum_fine, f.sum_fine)
  where f.name = p.name
    and f.number_plate = p.number_plate
    and f.violation = p.violation
    and f.date_payment is null;
 select * from fine;

------------------------------------------------------------------------------------------------------               
Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

create table back_payment as
select f.name, f.number_plate, f.violation, f.sum_fine, f.date_violation
from fine as f
where f.date_payment is null;
select * from back_payment;

------------------------------------------------------------------------------------------------------               
Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 

delete from fine
where date_violation < '2020-02-01 ';
select * from fine;

------------------------------------------------------------------------------------------------------               

Поиск по ключевым словам

На данном шаге можно найти шаги курса, в которых встречаются ключевые слова SQL, которые рассматриваются в курсе.

Для этого скопируйте один из запросов в окно решений, укажите нужные ключевые слова и запустите запрос. В окне решений будут выведены ссылки на соответствующие шаги.

Это НЕ ЗАДАНИЕ, а просто запросы, с помощью которых можно найти шаги, в которых встречаются те или иные ключевые слова. Выполнять не обязательно (это задание оценивается в 0 баллов). Это ПРОСТО ПОМОЩЬ для навигации по курсу.

Запрос 1. Поиск шагов, в которых встречается заданное ключевое слово, в примере MAX:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ", CONCAT(LEFT(step_name, 50), '...')) AS Шаг,
   note AS Примечание
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name = 'MAX'
ORDER BY 1;

Запрос 2. Поиск шагов, в которых встречаются два заданных ключевых слова одновременно, в примере MAX и AVG:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ", CONCAT(LEFT(step_name, 30), '...')) AS Шаг, 
   link AS Ссылка_на_шаг
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG')
GROUP BY ШАГ, Ссылка_на_шаг
HAVING count(*) = 2
ORDER BY 1;

 Запрос 3. Поиск шагов, в которых встречаются три заданных ключевых слова одновременно, в примере MAX, MIN и AVG:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ",step_name) AS Шаг
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG', 'MIN')
GROUP BY ШАГ
HAVING COUNT(*) = 3
ORDER BY 1;


------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------                 
				2.1. СВЯЗИ МЕЖДУ ТАБЛИЦАМИ

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы. 
Этапы реализации связи «один ко многим» на примере:
	1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе.
	2. Обе таблицы должны содержать первичный ключ (PK): book_id - в таблице  book,  author_id -  в таблице author.
	3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id)
------------------------------------------------------------------------------------------------------               
Создать таблицу author следующей структуры:

create table author (author_id int primary key auto_increment,
                     name_author varchar(50)
                    );


------------------------------------------------------------------------------------------------------               
Заполнить таблицу author. В нее включить следующих авторов:

    Булгаков М.А.
    Достоевский Ф.М.
    Есенин С.А.
    Пастернак Б.Л.

insert into author (name_author)
values ('Булгаков М.А.'),
       ('Достоевский Ф.М.'),
       ('Есенин С.А.'),
       ('Пастернак Б.Л.');


------------------------------------------------------------------------------------------------------               
Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре, показанной на логической схеме (таблица genre уже создана, порядок следования столбцов - как на логической схеме в таблице book, genre_id  - внешний ключ) . Для genre_id ограничение о недопустимости пустых значений не задавать. В качестве главной таблицы для описания поля  genre_idиспользовать таблицу genre следующей структуры:

create table book (book_id int primary key auto_increment,
                   title varchar(50),
                   author_id int not null,
                   genre_id int,
                   price decimal(8, 2),
                   amount int,
                   foreign key(author_id) references author(author_id),
                   foreign key(genre_id) references genre(genre_id)
                   );


------------------------------------------------------------------------------------------------------               
Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 

create table book (
    book_id int primary key auto_increment,
    title varchar(50),
    author_id int not null,
    genre_id int,
    price decimal(8,2),
    amount int,
    foreign key (author_id) references author (author_id) on delete cascade,
    foreign key (genre_id) references genre (genre_id) on delete set null
);
------------------------------------------------------------------------------------------------------               
Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:

insert into book (title, author_id, genre_id, price, amount)
values ('Стихотворения и поэмы', 3, 2, 650.00, 15),
       ('Черный человек', 3, 2, 570.20, 6),
       ('Лирика', 4, 2, 518.99, 2);
select * from book;

------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------                 
			2.2 Соединение INNER JOIN
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

select title, name_genre, price
from book as b
inner join genre as g on g.genre_id = b.genre_id
where amount > 8
order by price desc

------------------------------------------------------------------------------------------------------               
			    Вывести все жанры, которые не представлены в книгах на складе.

/*select
...
from 
    таблица_1 left join таблица_2
    on условие
... */
/* 
select name_author, title
from author left join book
    on author.author_id = book.author_id
order by name_author; 

--ниже то же самое, только переставил таблица, куда джонйнят (book)

select name_author, title
from book left join author on author.author_id = book.author_id
order by name_author;
select * from author;
select * from book;
*/
select name_genre
from genre as g left join book as b on g.genre_id = b.genre_id
where b.title is null;

с комментариев интересное решениепри помощи exists
SELECT g.name_genre
FROM genre g
WHERE NOT EXISTS(SELECT * from book b WHERE b.genre_id = g.genre_id);

------------------------------------------------------------------------------------------------------               
					Перекрестное соединение CROSS JOIN
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

select c.name_city, a.name_author, date_add('2020-01-01', interval (floor(rand() * 365)) day) as Дата
from city as c, author as a
--date_add('2020-01-01', interval floor(rand() * 365)) --прибавляем к начальной дате 2020-01-01 сгенерированное 
-- число
order by c.name_city, 3 desc

------------------------------------------------------------------------------------------------------               
					Запросы на выборку из нескольких таблиц
 Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

/*
table first ------>  table second (в первой таблице есть первичный ключ как и во второй, внешний ключ во второй таблице)
table second ----->  table third (--//--- как и в first ----> second)
*/
/*
select
...
from 
    first
    inner join second on first.first_id = second.first_id
    inner join third on second.second_id = third.second_id;
*/
/*
table first ------>   table third
table second ----->   table third
у каждого есть первичный ключ, первая и вторая указыают на третью на внешний ключ.
*/
/*
select
...
from 
    first
    inner join third on first.first_id = third.first_id
    inner join second on second.second_id = third.second_id;  
*/   
select g.name_genre, b.title, a.name_author
from 
    genre as g 
    inner join book as b on g.genre_id = b.genre_id
    inner join author as a on a.author_id = b.author_id
where g.name_genre = 'Роман'
order by title

------------------------------------------------------------------------------------------------------               
				Запросы для нескольких таблиц с группировкой

Посчитать количество экземпляров  книг каждого автора из таблицы author.  Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.

/* из-за inner не входят в выборку авторы, у которых нет книг
    select name_author, count(title) as Количество
    from author inner join book on author.author_id = book.author_id
    group by name_author
    order by name_author;
*/
/* сюда же авторы без книг уже входят
select name_author, count(title) as Количество
from 
    author left join book on author.author_id = book.author_id
group by name_author
order by name_author;
*/

select a.name_author, sum(b.amount) as Количество
from author as a left join book as b on a.author_id = b.author_id
group by a.name_author
having (sum(b.amount) < 10 or sum(b.amount) is null)
order by sum(b.amount);
------------------------------------------------------------------------------------------------------               
--Пример, вывести авторов, общее количество книг которых на складе максимаьно
/*    это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объеденим все запросы в один.
    Шаг 1. Найдем суммарное колиечество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id
*/
select b.author_id, sum(b.amount) as sum_amount
from book as b
group by b.author_id;
/* 
    Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присовить имя (например, query_in) и использовать его в качестве таблицы-источника после from. Затем уже находить максимум по столбцу sum_amount.
*/
select max(sum_amount) as max_sum_amount
from 
    (
     select b.author_id, sum(b.amount) as sum_amount
    from book as b
    group by b.author_id
    ) query_in;
/* Теперь собственно осталось только добавить к этому результату нижнему автора книги (мои мысли)
    Шаг 3. (теперь уже из курса) выведем фамилию автора и общее количество книг для него
*/
select a.name_author, sum(amount) as Количество
from author as a 
    inner join book as b on a.author_id = b.author_id
group by a.name_author;

/*
    Шаг 4. Включим запрос с шаг 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количесвто книг которых максимально
*/

select a.name_author, sum(amount) as Количество
from author as a 
    inner join book as b on a.author_id = b.author_id
group by a.name_author
having sum(amount) = 
    ( /*вычисляем максимальное из общего количества книг каждого автора */
        select max(sum_amount) as max_sum_amount
        from 
            (/* считаем количество книг каждого автора */
             select b.author_id, sum(b.amount) as sum_amount
             from book as b
             group by b.author_id
            ) query_in
    );
				




Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).
------------------------------------------------------------------------------------------------------               
				Запросы для нескольких таблиц со вложенными запросами

/*Задача :вывести авторов, общее количество книг которых на складе максимально

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один
*//*

шаг 1. 
Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии авторов в этой таблице нет, то группировку будем осуществлять по author_id */
select b.author_id, sum(b.amount) as sum_amount
from book as b
group by b.author_id;
/*

Шаг 2. В результрирущей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать его в качестве таблицы-источника после from. Затем уже находить максимум по столбцу sum_amount. */
select max(query_in.sum_amount) as max_sam_amount
from (
    select b.author_id, sum(b.amount) as sum_amount
    from book as b
    group by b.author_id
    ) query_in;

/*Шаг 3. Выведем фамилию автора и общее количество книг для него*/
select a.name_author, sum(b.amount) as Количество
from author as a inner join book as b on a.author_id = b.author_id
group by a.name_author;

/*Шаг 4. Включим в запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.*/
select a.name_author, sum(b.amount) as Количество
from author as a inner join book as b on a.author_id = b.author_id
group by a.name_author
having sum(b.amount) = 
    (/* вычисляем максимальное из общего количества книг каждого автора */
        select max(sum_amount) as max_sum_amount
        from 
            (/* считаем количество книг каждого автора */
                select b.author_id, sum(b.amount) as sum_amount
                from book as b
                group by b.author_id
                ) query_in
    );    

/*ЗАДАНИЕ
Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблице так занесены данные, что у каждого автора книги только в одном жанре, для этого запроса внесем изменеия в таблицу book. Пусть у нас книга Есенина "Черный человек" относится к жанру "Роман", а книга Булгакова "Белая гвардия" к "Приключениям" (эти изменеия в таблицы уже внесены) 
Решение
Шаг 1. выведем авторов и в каком жанре они пишут, сгруппируем по author_id (То есть нам нужно вытащить теперь автора под author_id 2 и 4, так как у них жанр только один)*/

select a.name_author 
from (
    select tt.author_id
    from 
        (/*Выведем авторов и жанр в котором они пишут, сгруппировав их по author_id */
        select b.author_id, b.genre_id
        from book as b
        group by b.author_id, b.genre_id
        ) tt
    group by tt.author_id
    having count(tt.genre_id) = 1 -- выводим только тех авторов, кто пишет только в одном жанре
    ) bb inner join author as a on a.author_id = bb.author_id /*вместо author_id выводим самих авторов*/  
order by bb.author_id    

------------------------------------------------------------------------------------------------------               
			Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения JOIN.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...

/*Пример
Выведем авторов, пишущих книги в самом популярном жанре (жанр, у которого(ых) количество книг на складе максимально). Указать этот жанр.

Шаг 1. Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя
Запрос
*/
select b.genre_id, sum(b.amount) as sum_amount
from book as b
group by b.genre_id
order by sum_amount desc
limit 1;
/*Кажется, что, уже используя этот запрос, можно получить id самого полулярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтму нам необходим запрос, который отберет все жанры, саммарное количество которых равно sum_amount

Шаг 2.Используя запрос с шага 1, найдем id самых популярных жанров
*/
select query_in_1.genre_id
from 
    (/* Выбираем код жанра и количество произведений, относящихся к нему */
      select b.genre_id, sum(b.amount) as sum_amount
      from book as b
      group by b.genre_id
    ) query_in_1 inner join (
        /* выбираем запись, в котором указан код жанр с максимальным количеством книг*/
        select b.genre_id, sum(b.amount) as sum_amount
        from book as b
        group by b.genre_id
        order by sum_amount desc
        limit 1
        ) query_in_2 on query_in_1.sum_amount = query_in_2.sum_amount;

/* Шаг 3
Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и название этих жанров. В этом запросе обязательно выполнить группировку по фамилии авторов и id жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре*/
select a.name_author, g.name_genre
from author as a
    inner join book as b on a.author_id = b.author_id
    inner join genre as g on b.genre_id = g.genre_id
group by a.name_author, g.name_genre, g.genre_id
having g.genre_id in 
        (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
            select query_in_1.genre_Id
            from 
                (select genre_id, sum(amount) as sum_amount
                 from book
                 group by genre_id              
                ) query_in_1 inner join
                (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                select genre_id, sum(amount) as sum_amount
                    from book
                    group by genre_id
                    order by sum_amount desc
                    limit 1
                ) query_in_2 on query_in_1.sum_amount = query_in_2.sum_amount
        
        );
/*
Важно!
Обратите внимание, что в группировку включен столбецgenre_id, который используется в HAVING. Это связано с тем, что в HAVING можно использовать либо столбцы, перечисленные в GROUP BY, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца genre_idне влияет на группировку, так как между названием жанра и его id - взаимно-однозначное соответствие.
Название столбца genre_id задается с указанием имени таблицы (genre.genre_id), так как этот столбец входит в структуру двух таблиц book и genre.  Для этого запроса можно было бы указать и book.genre_id, так как эти таблицы связаны внутренним соединением INNER JOIN и имеют одинаковые значения в полях genre.genre_id и book.genre_id.
*/

select b.title, a.name_author, g.name_genre, b.price, b.amount
from book as b 
    inner join author as a on a.author_id = b.author_id
    inner join 
    (select qq1.genre_id
     from
        (select b.genre_id, sum(b.amount) as sum_amount
        from book as b
         group by b.genre_id
         ) as qq1 inner join
        
         (select b.genre_id, sum(b.amount) as sum_amount
         from book as b
         group by b.genre_id
         order by sum_amount desc
         limit 1
         ) as qq2 on qq1.sum_amount = qq2.sum_amount       
   
    ) as tt on tt.genre_id = b.genre_id
    inner join genre as g on g.genre_id = tt.genre_id
order by title;


/* ниже представлено решение, более переработанное */
select b.title, a.name_author, g.name_genre, b.price, b.amount
from book as b 
    inner join author as a on a.author_id = b.author_id
    inner join 
   (
        select b.genre_id
        from book as b
        group by b.genre_id
        having sum(b.amount) =  
            (select sum(b.amount) as sum_amount
            from book as b
            group by b.genre_id
            order by sum_amount desc
            limit 1
            )  (следущий уровень вот этот select внутри join написать при помощи аналитической функции partition by)          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    ) as tt on tt.genre_id = b.genre_id
    inner join genre as g on g.genre_id = tt.genre_id
order by title;







(Ещё бы qq2 переделать на having внутри запроса qq1 вместо join qq1 и qq2)
------------------------------------------------------------------------------------------------------               
				Операция соединение, использование USING()
  При описании соединения таблиц с помощью join в некоторых случаях вместо on и следующего за ним условия можно использовать оператор using()
using позволяет указать набор столбцов, которые есть в обех объединяемых таблицах. Если база данных хорошо спрокетирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), тогда можно использовать предложение using для реализации операции join
  При этом после select, при использовании столбцов из using(), необязательно указывать, из какой именно таблицы берется столбец.

/*пример: вывести название книг, фамилии и id их авторов
вариант с ON */
select b.title, a.name_author, a.author_id /* явно указать таблицу - обязательно */
from author as a inner join book as b on a.author_id = b.author_id;

/* вариант с using*/
select b.title, a.name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно */
from author as a inner join book as b using(author_id);

/* Запись условия соединения с ON является более общим случаем, так как
        1. позволяет задавать соединения не только по одноименным полям
        2. позволяет использовать произвольное условие на соединение таблиц, при этом в условие может            включаться произвольное выражение, например, можно указать связь двух таблиц по двум и                более столбцам.
Пример
В таблице supply занесена информация о книгах, поступивших на склад
Если в таблицах supply и book есть одинаковые книги, вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковыми названиями

важно. В данном примере для соединения book и supply использовать using нельзя, так как:
        1. в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author,                  столбец name_author, а в таблице supply фамилии занесены в столбец author
        2. для озднозначной индетификации книги нужно указать, что совпадают не только названия, но и            авторы книг*/
select b.title, a.name_author
from book as b 
        inner join author as a using(author_id)
        inner join supply as s on b.title = s.title and a.name_author = s.author;

/* Задание 
Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах supply и book,  столбцы назвать Название, Автор  и Количество.
*/
select b.title, a.name_author, (sum(s.amount) + sum(b.amount)) as Количество
from book as b 
    inner join author as a using(author_id)
    inner join supply as s on s.title = b.title and s.author = a.name_author and b.price = s.price
group by b.title, a.name_author;


------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------  
				2.3 ЗАПРОСЫ КОРРЕКТИРОВКИ, СОЕДИНЕНИЯ ТАБЛИЦ
				Запросы на обновление, связанные таблицы

/*update таблица_1 
... join таблица_2 on выражение
    ...
set ...
where ...;
*/
/*
ПРИМЕР
    Для книг, которые уже есть на складе (в таблице book) по той же цене, что и в поставке (supply), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.
    Этот запрос должен отобрать строки из таблиц bookи supply такие, что у них совпадают и автор, и название книги. Но в таблице supply фамилия автора записана не числом (id), а текстом. Следовательно, чтобы выполнить сравнение по фамилии автора нужно "подтянуть" таблицу author,  которая связана с bookпо столбцу author_id.  И в логическом выражении, описывающем соединение таблиц, можно будет использовать столбцы из таблиц book, authorи supply. 
    Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор AND. Например, для следующих таблиц логическую связь по названию и автору:
*/
/*update book as b 
    inner join author as a on a.author_id = b.author_id
    inner join supply as s on b.title = s.title and s.author = a.name_author
set b.amount = b.amount + s.amount, s.amount = 0
where b.price = s.price;
select * from book;
select * from supply;
*/
/*
Задание
Для книг, которые уже есть на складе (в таблице book), но по другой цене, чем в поставках (supply), необходимо в таблице book увеличить количествно на значение, указанное в поставке, и пересчитать цену. А в таблице supply обнулить количество этих книг. 
Формула для расчета цены: price = (p1*k1 + p2*k2) / (k1 + k2)
где  p1, p2 - цена книги в таблицах book и supply;
     k1, k2 - количество книг в таблицах book и supply.
*/
update book as b 
    inner join author as a on a.author_id = b.author_id
    inner join supply as s on b.title = s.title and s.author = a.name_author
        set b.price = (b.price * b.amount + s.price * s.amount)/(b.amount + s.amount), 
        b.amount = b.amount + s.amount,
        s.amount = 0       
where b.price <> s.price;
select * from book;
select * from supply;
------------------------------------------------------------------------------------------------------               
				Запросы на добавление, связанные таблицы
Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:

insert into author (name_author)
select s.author
from author as a right join supply as s on a.name_author = s.author
where a.name_author is null;
select * from supply;

------------------------------------------------------------------------------------------------------               
			ШАГ 4 ИЗ 9

Добавить новые книги из таблицы supply в таблицу book на основе сформированного выше запроса. Затем вывести для просмотра таблицу book.

insert into book(title, author_id, genre_id, price, amount)
select s.title, a.author_id, null, s.price, s.amount
from author as a inner join supply as s on a.name_author = s.author
where s.amount <> 0;

select * from book;
------------------------------------------------------------------------------------------------------               
				ШАГ 5 ИЗ 9
			Запрос на обновление, вложенные запросы
 Занести для книги «Стихотворения и поэмы» Лермонтова жанр «Поэзия», а для книги «Остров сокровищ» Стивенсона - «Приключения». (Использовать два запроса).

update book as b
set b.genre_id = 
    (
     select g.genre_id
     from genre as g
     where g.name_genre = 'Поэзия'
    )
where b.book_id = 10;

update book as b
set b.genre_id = 
    (
     select g.genre_id
     from genre as g
     where g.name_genre = 'Приключения'
    )
where b.book_id = 11;

select * from book;

------------------------------------------------------------------------------------------------------               
				ШАГ 6 ИЗ 9
			Каскадное удаление записей связанных таблиц
/*ПРИМЕР
Удалим из таблицы author всех авторов, фамилия которых начинается на «Д», а из таблицы book  - все книги этих авторов.

delete from author as a
where a.name_author like 'Д%';
select * from author;
select * from book;  */

/* ЗАДАНИЕ 
Удалить всех авторов и все их книги, общее количество книг которых меньше 20.
подзапросом вытащу нужные мне id-шники авторов, а затем в where напишу, чтобы id-шник был в этом списке. Плевое дело! */
delete from author as a
where a.author_id in (select b.author_id
       from book as b
       group by b.author_id
       having sum(b.amount) < 20);
select * from author;
select * from book;


------------------------------------------------------------------------------------------------------               
				ШАГ 7 ИЗ 9
		Удаление записей главной таблицы с сохранением записей в зависимой

/*
    При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.
    Если задано SET NULL, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение NULL. (При этом в столбце внешнего ключа должно быть допустимо значение NULL)
В таблице book эта опция установлена на поле genre_id.
Пример
    Удалим из таблицы genre все  жанры, название которых заканчиваются на «я» , а в таблице book  -  для этих жанров установим значение Null.

delete from genre as g
where g.name_genre like '%я';
select * from genre;
select * from book; */

/* ЗАДАНИЕ
 Удалить все жанры, к которым относится меньше 4-х книг. В таблице book для этих жанров установить значение Null. */
delete from genre as g
where g.genre_id in 
    (select b.genre_id 
    from book as b
    group by b.genre_id
    having count(b.amount) < 4
    );
select * from book;
------------------------------------------------------------------------------------------------------               
				ШАГ 8 ИЗ 9
		Удаление записей, использование связанных таблиц
При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц. В этом случае синтаксис запроса имеет вид:
DELETE FROM таблица_1
USING 
    таблица_1 
    INNER JOIN таблица_2 ON ...
WHERE ...

/*Удалить всех авторов из таблицы author, у которых есть книги, количество экземпляров которых меньше 3. Из таблицы book удалить все книги этих авторов.
delete from author
using author inner join book on author.author_id = book.author_id
where book.amount < 3;
select * from author;
select * from book;
*/

Удалить всех авторов, которые пишут в жанре "Поэзия". Из таблицы book удалить все книги этих авторов. В запросе для отбора авторов использовать полное название жанра, а не его id.

(при помощи вложенного запроса в where)
delete from author
using author inner join book on author.author_id = book.author_id
where book.genre_id = (select g.genre_id from genre as g where g.name_genre = 'Поэзия');
select * from author;
select * from book;

(при помощи двух join-ов)
delete from author
using author inner join book on book.author_id = author.author_id
inner join genre on genre.genre_id = book.genre_id
where genre.name_genre = 'Поэзия';
select * from author;
select * from book;
------------------------------------------------------------------------------------------------------
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
------------------------------------------------------------------------------------------------------                                2.4 База данных «Интернет-магазин книг», запросы на выборку 
				ШАГ 5 ИЗ 16
			Запросы на основе трех и более связанных таблиц
/*Вывести фамилии всех клиентов, которые заказали книгу Булгакова «Мастер и Маргарита».*/
/*select distinct cl.name_client, bb.amount
from client as cl
    inner join buy on cl.client_id = buy.client_id
    inner join buy_book as bb on bb.buy_id = buy.buy_id
    inner join book as b on bb.book_id = b.book_id
where title = 'Мастер и Маргарита' and b.author_id = 1;
*/
/*Вывести все заказы Баранова Павла (id заказа, какие книги, по какой цене и в каком количестве он заказал) в отсортированном по номеру заказа и названиям книг виде.*/
select buy.buy_id, b.title, b.price, bb.amount
from client as cl 
    inner join buy on cl.client_id = buy.client_id
    inner join buy_book as bb on buy.buy_id = bb.buy_id
    inner join book as b on bb.book_id = b.book_id
where cl.name_client = 'Баранов Павел'
order by buy.buy_id, b.title;

------------------------------------------------------------------------------------------------------               				ШАГ 6 ИЗ 16
Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать, в каком количестве заказов фигурирует каждая книга).  Вывести фамилию и инициалы автора, название книги, последний столбец назвать Количество. Результат отсортировать сначала  по фамилиям авторов, а потом по названиям книг.

select a.name_author, b.title, coalesce(tt.Количество, 0) as Количество
from book as b 
    left join 
        (select bb.book_id, count(bb.amount) as Количество
        from buy_book as bb
        group by bb.book_id
        ) as tt on tt.book_id = b.book_id
    left join author as a on b.author_id = a.author_id
order by a.name_author, b.title
------------------------------------------------------------------------------------------------------               
				ШАГ 7 ИЗ 16
Вывести города, в которых живут клиенты, оформлявшие заказы в интернет-магазине. Указать количество заказов в каждый город, этот столбец назвать Количество. Информацию вывести по убыванию количества заказов, а затем в алфавитном порядке по названию городов.

select c.name_city, count(buy.buy_id) as Количество
from city as c 
    inner join client as cl on c.city_id = cl.city_id
    inner join buy on buy.client_id = cl.client_id
group by c.name_city
order by 2 desc, c.name_city
------------------------------------------------------------------------------------------------------               				ШАГ 8 ИЗ 16
Вывести номера всех оплаченных заказов и даты, когда они были оплачены.

select bs.buy_id, bs.date_step_end
from buy_step as bs inner join step as s on bs.step_id = s.step_id
where bs.date_step_end is not null and s.name_step = 'Оплата';


------------------------------------------------------------------------------------------------------               				ШАГ 9 ИЗ 16

    Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде. Последний столбец назвать Стоимость.

select buy.buy_id, cl.name_client, sum(bb.amount * b.price) as Стоимость
from buy 
    inner join client   as cl on buy.client_id = cl.client_id
    inner join buy_book as bb on buy.buy_id = bb.buy_id
    inner join book     as b  on b.book_id = bb.book_id
group by buy.buy_id, cl.client_id 
order by buy.buy_id;

(То же самое, только реализованное при помощи using)
select buy.buy_id, cl.name_client, sum(bb.amount * b.price) as Стоимость
from buy 
    inner join client   as cl using(client_id)
    inner join buy_book as bb using(buy_id)
    inner join book     as b  using(book_id)
group by buy.buy_id, cl.client_id 
order by buy.buy_id;
------------------------------------------------------------------------------------------------------               				ШАГ 10 ИЗ 16
Вывести номера заказов (buy_id) и названия этапов,  на которых они в данный момент находятся. Если заказ доставлен –  информацию о нем не выводить. Информацию отсортировать по возрастанию buy_id.
Пояснение -  текущим  считается тот этап, для которого заполнена дата начала этапа и не заполнена дата его окончания.

select bs.buy_id, step.name_step
from buy_step as bs inner join step using(step_id)
where bs.date_step_beg is not null and bs.date_step_end is null
order by bs.buy_id
------------------------------------------------------------------------------------------------------               				ШАГ 11 из 16
В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город (рассматривается только этап Транспортировка). Для тех заказов, которые прошли этап транспортировки, вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, в противном случае вывести 0. В результат включить номер заказа (buy_id), а также вычисляемые столбцы Количество_дней и Опоздание. Информацию вывести в отсортированном по номеру заказа виде.
Пояснение
    Для вычисления поля «Опоздание» используйте функцию if(), а для вычисления разности дат – функцию DATEDIFF().
    Если доставка еще не осуществлена, то поле date_step_end  для этапа Транспортировка - пусто.

select buy.buy_id, datediff(date_step_end, date_step_beg) as Количество_дней, if(datediff(date_step_end, date_step_beg) > days_delivery, (datediff(date_step_end, date_step_beg) - days_delivery), 0) as Опоздание
from city
    inner join client using(city_id)
    inner join buy using(client_id)
    inner join buy_step as bs using(buy_id)
where bs.step_id = 3 and bs.date_step_end is not null
order by buy.buy_id;


------------------------------------------------------------------------------------------------------               				ШАГ 12 из 16
Задание
Выбрать всех клиентов, которые заказывали книги Достоевского, информацию вывести в отсортированном по алфавиту виде. В решении используйте фамилию автора, а не его id.

select distinct cl.name_client 
from client as cl
    inner join buy using(client_id)
    inner join buy_book as bs using(buy_id)
    inner join book as b using(book_id)
    inner join author as a using(author_id)
where a.name_author = 'Достоевский Ф.М.'
order by 1

------------------------------------------------------------------------------------------------------               				ШАГ 13 из 16
Вывести жанр (или жанры), в котором было заказано больше всего экземпляров книг, указать это количество. Последний столбец назвать Количество.
	Пояснение
Использовать вложенный запрос для вычисления максимального значения экземпляров книг.  Рекомендуется запрос реализовывать по шагам.

select genre.name_genre, sum(bb.amount) as Количество
from genre 
    inner join book using(genre_id)
    inner join buy_book as bb using(book_id)
group by genre.name_genre
having sum(bb.amount) = 
        (/*вычислим жанр, в котором больше всего покупок*/
	select max(tt.sum_amount)
        from (/*посчитаем количество заказанных книг по жанрам*/
                select b.genre_id, sum(bb.amount) as sum_amount
                from book as b inner join buy_book as bb using(book_id)
                group by b.genre_id
             ) tt
        );
------------------------------------------------------------------------------------------------------               				ШАГ 14 из 16
			https://stepik.org/lesson/308891/step/14?unit=291017
Оператор UNION

Оператор UNION используется для объединения двух и более SQL запросов, его синтаксис:

SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...

или

SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
/*Вывести всех клиентов, которые делали заказы или в этом, или в предыдущем году.
select cl.name_client
from buy_archive as ba
    inner join client as cl using(client_id)
union all
select cl.name_client
from buy
    inner join client as cl using(client_id);

select cl.name_client
from buy_archive as ba
    inner join client as cl using(client_id)
union
select cl.name_client
from buy
    inner join client as cl using(client_id);


Вывести информацию об оплаченных заказах за предыдущий и текущий год, информацию 
отсортировать по  client_id.

select ba.buy_id, ba.client_id, ba.book_id, ba.date_payment, ba.amount, ba.price
from buy_archive as ba;
--union all
select buy.buy_id, client_id, bb.book_id, bs.date_step_end, bb.amount, b.price
from book as b
     inner join buy_book bb using(book_id)
     inner join buy using(buy_id)
     inner join buy_step bs using(buy_id)
     inner join step using(step_id) 
where bs.date_step_end is not null and step.name_step = 'Оплата'
order by client_id;
*/	
В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020

	Задание
Сравнить ежемесячную выручку от продажи книг за текущий и предыдущий годы. Для этого вывести год, месяц, сумму выручки в отсортированном сначала по возрастанию месяцев, затем по возрастанию лет виде. Название столбцов: Год, Месяц, Сумма.

В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020

select year(ba.date_payment) as Год, monthname(ba.date_payment) as Месяц, sum(ba.price * ba.amount) as Сумма
from buy_archive as ba
group by year(ba.date_payment), monthname(ba.date_payment)
union
select year(bs.date_step_end), monthname(bs.date_step_end), sum(bb.amount * b.price)
from buy_step as bs 
    inner join step using(step_id)
    inner join buy using(buy_id)
    inner join buy_book as bb using(buy_id)
    inner join book as b using(book_id)
where bs.date_step_end is not null and name_step = 'Оплата'
group by year(bs.date_step_end), monthname(bs.date_step_end)
order by Месяц, Год;
------------------------------------------------------------------------------------------------------               				ШАГ 15 из 16
/*
Пример
Вывести клиентов, которые делали покупки в прошлом году, но не делали в этом. А также новых клиентов, которые делали заказы только в текущем году. Информацию отсортировать по возрастанию лет.

Шаг 1. Отберем клиентов прошлого года, указав дату самого раннего заказа, а также клиентов этого года, указав для них самую раннюю дату оплаты заказа.
Запрос
SELECT name_client, MIN(date_payment) AS first_payment
FROM 
    buy_archive 
    INNER JOIN client USING(client_id)
GROUP BY  name_client
UNION
SELECT name_client, MIN(date_step_end)
FROM 
    buy 
    INNER JOIN client USING(client_id)
    INNER JOIN buy_step USING(buy_id)
GROUP BY name_client

Результат:

+-----------------+---------------+
| name_client     | first_payment |
+-----------------+---------------+
| Абрамова Катя   | 2019-02-10    |
| Баранов Павел   | 2019-02-21    |
| Яковлева Галина | 2019-03-05    |
| Абрамова Катя   | 2020-03-05    |
| Баранов Павел   | 2020-02-20    |
| Семенонов Иван  | 2020-02-28    |
+-----------------+---------------+

Как видно из таблицы, некоторые клиенты делали покупки как в прошлом, так и в этом году. Они встречаются в таблице 2 раза.

Шаг 2. Оставим только тех клиентов, которые встречаются в полученной таблице один раз, для этого используем предыдущий запрос как вложенный.

Запрос:

SELECT name_client, MIN(YEAR(first_payment)) AS Год
FROM
  (
   SELECT name_client, MIN(date_payment) AS first_payment
   FROM 
       buy_archive 
       INNER JOIN client USING(client_id)
   GROUP BY  name_client
   UNION
   SELECT name_client, MIN(date_step_end)
   FROM 
       buy 
       INNER JOIN client USING(client_id)
       INNER JOIN buy_step USING (buy_id)
   GROUP BY name_client
  ) query_in
GROUP BY name_client
HAVING COUNT(*) = 1
ORDER BY 2
*/



    Для каждой отдельной книги необходимо вывести информацию о количестве проданных экземпляров и их стоимости за 2020 и 2019 год . Вычисляемые столбцы назвать Количество и Сумма. Информацию отсортировать по убыванию стоимости.

select t.title, sum(t.Количество) as Количество, sum(t.Сумма) as Сумма
from 
(
select b.title, sum(ba.amount) as Количество, sum(ba.price * ba.amount) as Сумма
from  buy_archive as ba
    inner join book b using(book_id)
group by b.title
union all
select b.title, sum(bb.amount), sum(bb.amount * b.price)
from buy_book bb 
    inner join book b using(book_id)
    inner join buy_step bs using(buy_id)
where bs.date_step_end is not null and bs.step_id = 1
group by b.title
) t
group by t.title
order by 3 desc;

------------------------------------------------------------------------------------------------------    					2.1            
В запросах на добавление можно одновременно заносить и константы, и данные из других таблиц. Для этого в той части запроса INSERT , где задается запрос на выборку, в качестве полей для вставки указываются не только поля других таблиц, но и  константы:

INSERT INTO ... 
SELECT 'Попов Илья', city_id, 'popov@test'
FROM city
WHERE ...;

Задание
Включить нового человека в таблицу с клиентами. Его имя Попов Илья, его email popov@test, проживает он в Москве.

insert into client (name_client, city_id, email)
select 'Попов Илья', city_id, 'popov@test'
from city
where city_id = 1;
select * from client;
-----------------------------------------------------------------------------------------------------2.2

 Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».
insert into buy(buy_description, client_id)
select 'Связаться со мной по поводу доставки', client_id
from client
where name_client = 'Попов Илья';
select * from buy;


------------------------------------------------------------------------------------------------------               				2.3.
 Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».

insert into buy (buy_description, client_id)
select 'Связаться со мной по вопросу доставки', client_id
from client
where name_client = 'Попов Илья';
select * from buy;
------------------------------------------------------------------------------------------------------               				2.4
Задание
В таблицу buy_book добавить заказ с номером 5. Этот заказ должен содержать книгу Пастернака «Лирика» в количестве двух экземпляров и книгу Булгакова «Белая гвардия» в одном экземпляре.

insert into buy_book (buy_id, book_id, amount)
select 5, b.book_id, 2
from book as b
where b.title = 'Лирика' and author_id = (
    select b.author_id
    from book as b inner join author as a using(author_id)
    where a.name_author = 'Пастернак Б.Л.' and b.title = 'Лирика');
    
insert into buy_book (buy_id, book_id, amount)
select 5, b.book_id, 1
from book as b
where b.title = 'Белая гвардия' and author_id = (
    select b.author_id
    from book as b inner join author as a using(author_id)
    where a.name_author = 'Булгаков М.А.' and b.title = 'Белая гвардия'); 


------------------------------------------------------------------------------------------------------               				2.5

Задание
Количество тех книг на складе, которые были включены в заказ с номером 5, уменьшить на то количество, которое в заказе с номером 5  указано.

update book b, buy_book bb
set b.amount = b.amount - bb.amount
where buy_id = 5 and b.book_id = bb.book_id;

select * from book;
------------------------------------------------------------------------------------------------------               				2.6
Задание
Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену, количество заказанных книг и  стоимость. Последний столбец назвать Стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.

create table buy_pay as
select b.title, a.name_author, b.price, bb.amount, sum(b.price * bb.amount) as Стоимость
from book as b
    inner join author as a using(author_id)
    inner join buy_book as bb using(book_id)
where buy_id = 5
group by b.title, a.name_author, b.price, bb.amount
order by b.title;

select * from buy_pay;
------------------------------------------------------------------------------------------------------               				2.7
Задание
Создать общий счет (таблицу buy_pay) на оплату заказа с номером 5. Куда включить номер заказа, количество книг в заказе (название столбца Количество) и его общую стоимость (название столбца Итого). Для решения используйте ОДИН запрос.

create table buy_pay as
select bb.buy_id, sum(bb.amount) as Количество, sum(bb.amount * b.price) as Итого
from buy_book as bb
    inner join book as b using(book_id)
where bb.buy_id = 5    
group by bb.buy_id;

select * from buy_pay;

------------------------------------------------------------------------------------------------------               				2.8
Задание
В таблицу buy_step для заказа с номером 5 включить все этапы из таблицы step, которые должен пройти этот заказ. В столбцы date_step_beg и date_step_end всех записей занести Null.

insert into buy_step (buy_id, step_id, date_step_beg, date_step_end)
select 5, step_id, null, null
from step;
select * from buy_step;

------------------------------------------------------------------------------------------------------               				2.9
Задание
В таблицу buy_step занести дату 12.04.2020 выставления счета на оплату заказа с номером 5.

Правильнее было бы занести не конкретную, а текущую дату. Это можно сделать с помощью функции Now(). Но при этом в разные дни будут вставляться разная дата, и задание нельзя будет проверить, поэтому  вставим дату 12.04.2020.

update buy_step
set date_step_beg = '2020.04.12'
where buy_id = 5 and step_id = (select step_id from step where name_step = 'Оплата');
select * from buy_step
where buy_id = 5;
------------------------------------------------------------------------------------------------------               				2.10
Задание

Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»), задав в столбце date_step_beg для этого этапа ту же дату.

Реализовать два запроса для завершения этапа и начала следующего. Они должны быть записаны в общем виде, чтобы его можно было применять для любых этапов, изменив только текущий этап. Для примера пусть это будет этап «Оплата»

update buy_step 
set date_step_end = '2020.04.13'
where buy_id = 5 and step_id = (select step_id from step where name_step = 'Оплата');

update buy_step 
set date_step_beg = '2020.04.13'
where buy_id = 5 and step_id = (select step_id from step where name_step = 'Упаковка');

select * from buy_step
where buy_id = 5;

------------------------------------------------------------------------------------------------------               				3.1-3.2 База данных «Тестирование», запросы на выборку
Задание
Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. Информацию вывести по убыванию результатов тестирования.

select st.name_student, a.date_attempt, a.result
from attempt as a 
    inner join student as st using(student_id)
    inner join subject as sb using(subject_id)
where sb.name_subject = 'Основы баз данных'
order by result desc;

------------------------------------------------------------------------------------------------------               				3.3 

Задание
Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, который округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы теста, который занесен в столбец result.  В результат включить название дисциплины, а также вычисляемые столбцы Количество и Среднее. Информацию вывести по убыванию средних результатов.

select sb.name_subject, count(a.subject_id) as Количество, round(sum(a.result) / count(a.result), 2) as Среднее
from subject as sb
    left join attempt as a using(subject_id)
group by sb.name_subject
order by 3 desc;


------------------------------------------------------------------------------------------------------               				3.4 

Задание
Вывести студентов (различных студентов), имеющих максимальные результаты попыток. Информацию отсортировать в алфавитном порядке по фамилии студента.
Максимальный результат не обязательно будет 100%, поэтому явно это значение в запросе не задавать.

select st.name_student, a.result
from attempt as a
    inner join student as st using(student_id)
where a.result = (
    select max(a.result)
    from attempt as a)
order by st.name_student;


------------------------------------------------------------------------------------------------------               3.5
					 
Задание
Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и последней попыткой. В результат включить фамилию и имя студента, название дисциплины и вычисляемый столбец Интервал. Информацию вывести по возрастанию разницы. Студентов, сделавших одну попытку по дисциплине, не учитывать. 

select st.name_student, sb.name_subject, datediff(max(a.date_attempt), min(date_attempt)) as Интервал
from attempt as a
    inner join student as st using(student_id)
    inner join subject as sb using(subject_id)
group by st.name_student, sb.name_subject
having count(a.date_attempt) > 1
order by datediff(max(a.date_attempt), min(date_attempt));

------------------------------------------------------------------------------------------------------          
		3.6

Задание
Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем). Вывести дисциплину и количество уникальных студентов (столбец назвать Количество), которые по ней проходили тестирование . Информацию отсортировать сначала по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, тестирование по которым студенты еще не проходили, в этом случае указать количество студентов 0.

select sb.name_subject, count(distinct a.student_id) as Количество
from subject as sb
    left join attempt as a using(subject_id)
group by sb.name_subject
order by 2 desc, 1;    

------------------------------------------------------------------------------------------------------          		3.7
Задание
Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных». В результат включите столбцы question_id и name_question.    

select q.question_id, q.name_question
from question as q
where q.subject_id = (select s.subject_id from subject as s where s.name_subject = 'Основы баз данных')
order by 1
limit 3;
------------------------------------------------------------------------------------------------------          		3.8
Задание
Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  (значение attempt_id для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет (вывести Верно или Неверно). В результат включить вопрос, ответ и вычисляемый столбец  Результат.
    
select q.name_question, a.name_answer, if(a.is_correct = 1, 'Верно', 'Неверно') as Результат
from question as q     
    inner join testing as t using(question_id)
    inner join answer as a using(answer_id)
where q.subject_id = (select sb.subject_id
       from subject as sb
       where sb.name_subject = 'Основы SQL')
       and t.attempt_id = 7;

------------------------------------------------------------------------------------------------------          
		3.9
Задание
Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. Вывести фамилию студента, название предмета, дату и результат. Последний столбец назвать Результат. Информацию отсортировать сначала по фамилии студента, потом по убыванию даты попытки.

select st.name_student, sb.name_subject, att.date_attempt, round(sum(is_correct)*100/3, 2) Результат
from answer as a
    inner join testing using(answer_id)
    inner join attempt att using(attempt_id)
    inner join subject sb using(subject_id)
    inner join student st using(student_id)
group by 1, 2, 3
order by 1, 3 desc

или вот так

SELECT name_student,
       name_subject,
       date_attempt,
       ROUND((SUM(answer.is_correct) / COUNT(question.question_id) * 100), 2) AS Результат
  FROM attempt
       JOIN student  USING (student_id)
       JOIN testing  USING (attempt_id)
       JOIN subject  USING (subject_id)
       JOIN question USING (question_id)
       JOIN answer   USING (answer_id)
 GROUP BY name_student,
       name_subject,
       date_attempt
 ORDER BY name_student ASC,
       date_attempt DESC


------------------------------------------------------------------------------------------------------         
	3.1.10
Задание 
Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству ответов, значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, и общее количество ответов на этот вопрос. В результат включить название дисциплины, вопросы по ней (столбец назвать Вопрос), а также два вычисляемых столбца Всего_ответов и Успешность. Информацию отсортировать сначала по названию дисциплины, потом по убыванию успешности, а потом по тексту вопроса в алфавитном порядке.
 
select sb.name_subject, 
       CONCAT(LEFT(q.name_question, 30), '...') as Вопрос,
       count(t.answer_id) as Всего_ответов,
       round(100 * sum(a.is_correct) / count(t.answer_id), 2) as Успешность
from subject sb
     inner join question q on sb.subject_id = q.subject_id
     inner join testing t on q.question_id = t.question_id
     left join answer a on t.answer_id = a.answer_id
group by sb.name_subject, q.name_question
order by sb.name_subject, 4 desc, 2


------------------------------------------------------------------------------------------------------          
	3.2.2
Задание
В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». Установить текущую дату в качестве даты выполнения попытки.

insert into attempt (student_id, subject_id, date_attempt, result)
select (select distinct student_id from attempt 
       left join student using(student_id)
       where name_student = 'Баранов Павел'),
       (select distinct subject_id from attempt 
       left join subject using(subject_id)
       where name_subject = 'Основы баз данных'),
       now(),
       null
from attempt
    inner join subject using(subject_id)
    inner join student using(student_id)
where name_subject = 'Основы баз данных' and name_student = 'Баранов Павел';
select * from attempt;
------------------------------------------------------------------------------------------------------          	3.2.3  
Задание 
Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, занесенный в таблицу attempt последним, и добавить их в таблицу testing. id последней попытки получить как максимальное значение id из таблицы attempt.

insert into testing (attempt_id, question_id)
select a.attempt_id, q.question_id
from question q
    inner join attempt a using(subject_id)
where a.attempt_id = (select max(attempt_id) from attempt)
order by rand()
limit 3;
select * from testing
------------------------------------------------------------------------------------------------------          
	3.2.4
Задание
Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.
Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8. В таблицу testing занесены следующие ответы пользователя:

update attempt
set result = (select (round(100 * sum(a.is_correct) / count(a.is_correct)))
    from answer a
        inner join testing t using(answer_id)
    where t.attempt_id = 8)
where attempt_id = 8;
select * from attempt;
                   
------------------------------------------------------------------------------------------------------         
	3.2.5
Задание
Удалить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим попыткам вопросы из таблицы testing, которая создавалась следующим запросом:

delete from attempt
where date_attempt < '2020-05-01';
select * from attempt;
select * from testing;
------------------------------------------------------------------------------------------------------               
			3.3.2
Задание
Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в отсортированном по фамилиям виде.

select e.name_enrollee
from enrollee e 
    inner join program_enrollee using(enrollee_id)
    inner join program p using(program_id)
where p.name_program = 'Мехатроника и робототехника'
order by 1;

------------------------------------------------------------------------------------------------------               3.3.3
Задание
Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать в обратном алфавитном порядке.

select name_program
from program p
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on ps.subject_id = s.subject_id
where name_subject = 'Информатика'
order by 1 desc;

------------------------------------------------------------------------------------------------------          
		3.3.4
Задание
Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов по предмету ЕГЭ. Вычисляемые столбцы назвать Количество, Максимум, Минимум, Среднее. Информацию отсортировать по названию предмета в алфавитном порядке, среднее значение округлить до одного знака после запятой.

select s.name_subject,
       count(*) as Количество,
       max(es.result) as Максимум,
       min(es.result) as Минимум,
       round(avg(es.result),1) as Среднее
from enrollee_subject es
    inner join subject s on s.subject_id = es.subject_id
group by 1
order by 1;
------------------------------------------------------------------------------------------------------          
		3.3.5
Задание
Вывести образовательные программы, для которых минимальный балл ЕГЭ по каждому предмету больше или равен 40 баллам. Программы вывести в отсортированном по алфавиту виде.

select p.name_program
from program_subject ps
    inner join program p on p.program_id = ps.program_id
group by p.name_program
having min(ps.min_result) >= 40
order by 1;

------------------------------------------------------------------------------------------------------          
		3.3.6
Задание
Вывести образовательные программы, которые имеют самый большой план набора,  вместе с этой величиной.

select name_program, plan
from program
where plan = (select max(plan) from program)
------------------------------------------------------------------------------------------------------          
		3.3.7
Задание
Посчитать, сколько дополнительных баллов получит каждый абитуриент. Столбец с дополнительными баллами назвать Бонус. Информацию вывести в отсортированном по фамилиям виде.

select e.name_enrollee, if(sum(a.bonus) is null, 0, sum(a.bonus)) as Бонус
from enrollee e
    left join enrollee_achievement ea on e.enrollee_id = ea.enrollee_id
    left join achievement a on ea.achievement_id = a.achievement_id
group by e.name_enrollee
order by 1;
------------------------------------------------------------------------------------------------------          
		3.3.8.
Задание
Выведите сколько человек подало заявление на каждую образовательную программу и конкурс на нее (число поданных заявлений деленное на количество мест по плану), округленный до 2-х знаков после запятой. В запросе вывести название факультета, к которому относится образовательная программа, название образовательной программы, план набора абитуриентов на образовательную программу (plan), количество поданных заявлений (Количество) и Конкурс. Информацию отсортировать в порядке убывания конкурса.

select d.name_department, p.name_program, p.plan, count(p.name_program) as Количество, round(count(p.name_program)/ (p.plan), 2) as Конкурс 
from program_enrollee pe
    inner join program p using(program_id)
    inner join department d using(department_id )
group by d.name_department, p.name_program, p.plan
order by 5 desc;
------------------------------------------------------------------------------------------------------          		3.3.9
Задание
Вывести образовательные программы, на которые для поступления необходимы предмет «Информатика» и «Математика» в отсортированном по названию программ виде.
     
select p.name_program
from (select program_id, name_program,department_id, plan
from program p 
    inner join program_subject using(program_id)
    inner join subject s using(subject_id)
where s.name_subject = 'Информатика') p 
    left join program_subject ps on p.program_id = ps.program_id
    left join subject s on s.subject_id = ps.subject_id      
where s.name_subject = 'Математика'
order by 1;

------------------------------------------------------------------------------------------------------          
		3.3.10
Задание
Посчитать количество баллов каждого абитуриента на каждую образовательную программу, на которую он подал заявление, по результатам ЕГЭ. В результат включить название образовательной программы, фамилию и имя абитуриента, а также столбец с суммой баллов, который назвать itog. Информацию вывести в отсортированном сначала по образовательной программе, а потом по убыванию суммы баллов виде.

select p.name_program, e.name_enrollee, sum(es.result) as itog
from enrollee e
    inner join program_enrollee pe on pe.enrollee_id = e.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on es.subject_id = s.subject_id and e.enrollee_id = es.enrollee_id 
group by p.name_program, e.name_enrollee
order by p.name_program, 3 desc;
------------------------------------------------------------------------------------------------------          
		3.3.11
Задание
	Вывести название образовательной программы и фамилию тех абитуриентов, которые подавали документы на эту образовательную программу, но не могут быть зачислены на нее. Эти абитуриенты имеют результат по одному или нескольким предметам ЕГЭ, необходимым для поступления на эту образовательную программу, меньше минимального балла. Информацию вывести в отсортированном сначала по программам, а потом по фамилиям абитуриентов виде.
	Например, Баранов Павел по «Физике» набрал 41 балл, а  для образовательной программы «Прикладная механика» минимальный балл по этому предмету определен в 45 баллов. Следовательно, абитуриент на данную программу не может поступить.

# Ну и зачем ты тут использовал группировку. Если прочитать условие, то становится понятно, что группировка тут не нужна, а нужно только условие (результат тестирования меньше минимального для зачисления)
/* ЭТО НЕПРАВИЛЬНЫЙ ВАРИАНТ ОТВЕТА
select p.name_program, e.name_enrollee , sum(es.result), sum(ps.min_result)
from enrollee e 
    inner join program_enrollee pe on e.enrollee_id = pe.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on s.subject_id = es.subject_id and e.enrollee_id = es.enrollee_id
where es.result >= ps.min_result
group by p.name_program, e.name_enrollee
having (sum(ps.min_result) / sum(es.result)) <= 1
*/
ВОТ ЭТОТ НИЖЕ ПРАВИЛЬНЫЙ.

select p.name_program, e.name_enrollee # (, es.result, ps.min_result # sum(es.result), sum(ps.min_result) )
from enrollee e 
    inner join program_enrollee pe on e.enrollee_id = pe.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on s.subject_id = es.subject_id and e.enrollee_id = es.enrollee_id
where es.result <= ps.min_result
order by p.name_program, e.name_enrollee
------------------------------------------------------------------------------------------------------          


				3.4.2
Задание
Создать вспомогательную таблицу applicant,  куда включить id образовательной программы, id абитуриента, сумму баллов абитуриентов (столбец itog) в отсортированном сначала по id образовательной программы, а потом по убыванию суммы баллов виде (использовать запрос из предыдущего урока).

create table applicant as
select p.program_id, e.enrollee_id, sum(es.result) as itog
from enrollee e
    inner join program_enrollee pe on pe.enrollee_id = e.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on es.subject_id = s.subject_id and e.enrollee_id = es.enrollee_id 
group by p.program_id, e.enrollee_id
order by p.program_id, sum(es.result) desc;

select * from applicant
------------------------------------------------------------------------------------------------------          
		3.4.3
Задание
Из таблицы applicant, созданной на предыдущем шаге, удалить записи, если абитуриент на выбранную образовательную программу не набрал минимального балла хотя бы по одному предмету (использовать запрос из https://stepik.org/lesson/310418/step/11?unit=292724 предыдущего урока).

delete from applicant
using applicant
inner join (
select p.program_id, e.enrollee_id
from enrollee e 
    inner join program_enrollee pe on e.enrollee_id = pe.enrollee_id
    inner join program p on p.program_id = pe.program_id
    inner join program_subject ps on p.program_id = ps.program_id
    inner join subject s on s.subject_id = ps.subject_id
    inner join enrollee_subject es on s.subject_id = es.subject_id and e.enrollee_id = es.enrollee_id
where es.result <= ps.min_result
order by p.program_id, e.enrollee_id
) tt on tt.program_id = applicant.program_id and tt.enrollee_id = applicant.enrollee_id;
select * from applicant;
------------------------------------------------------------------------------------------------------          
		3.4.4
Задание
Повысить итоговые баллы абитуриентов в таблице applicant на значения дополнительных баллов (использовать запрос из предыдущего урока https://stepik.org/lesson/310418/step/7?unit=292724).

update applicant
    inner join (
select e.enrollee_id, if(sum(a.bonus) is null, 0, sum(a.bonus)) as Бонус
from enrollee e
    left join enrollee_achievement ea on e.enrollee_id = ea.enrollee_id
    left join achievement a on ea.achievement_id = a.achievement_id
group by e.enrollee_id
order by 1
) tt on tt.enrollee_id = applicant.enrollee_id
set itog = itog + Бонус;
select * from applicant;
------------------------------------------------------------------------------------------------------          
		3.4.5
Задание
Поскольку при добавлении дополнительных баллов, абитуриенты по каждой образовательной программе могут следовать не в порядке убывания суммарных баллов, необходимо создать новую таблицу applicant_order на основе таблицы applicant. При создании таблицы данные нужно отсортировать сначала по id образовательной программы, потом по убыванию итогового балла. А таблицу applicant, которая была создана как вспомогательная, необходимо удалить.

create table applicant_order
select a.program_id, a.enrollee_id, a.itog 
from applicant a
order by 1, 3 desc;

drop table applicant;
select * from applicant_order;
------------------------------------------------------------------------------------------------------          
		3.4.6

Для отбора рекомендованных к зачислению студентов можно разработать различные алгоритмы. Мы реализуем несколько SQL запросов. В первом запросе вставим в таблицу applicant_order новый столбец для последовательной нумерации строк. 
Для изменения структуры таблицы используется оператор ALTER TABLE. С его помощью можно вставить новый столбец, удалить существующий, переименовать столбец и пр.
Для вставки нового столбца используется SQL запросы:
ALTER TABLE таблица ADD имя_столбца тип; - вставляет столбец после последнего
ALTER TABLE таблица ADD имя_столбца тип FIRST; - вставляет столбец перед первым
ALTER TABLE таблица ADD имя_столбца тип AFTER имя_столбца_1; - вставляет столбец после укзанного столбца
Для удаления столбца используется SQL запросы:
ALTER TABLE таблица DROP COLUMN имя_столбца; - удаляет столбец с заданным именем
ALTER TABLE таблица DROP имя_столбца; - ключевое слово COLUMN не обязательно указывать
ALTER TABLE таблица DROP имя_столбца,
                    DROP имя_столбца_1; - удаляет два столбца
Для переименования столбца используется  запрос (тип данных указывать обязательно):
ALTER TABLE таблица CHANGE имя_столбца новое_имя_столбца ТИП ДАННЫХ;
Для изменения типа  столбца используется запрос (два раза указывать имя столбца обязательно): 
ALTER TABLE таблица CHANGE имя_столбца имя_столбца НОВЫЙ_ТИП_ДАННЫХ;

Задание
Включить в таблицу applicant_order новый столбец str_id целого типа , расположить его перед первым.

alter table applicant_order add str_id int first;
select * from applicant_order;

------------------------------------------------------------------------------------------------------          		3.4.7

Задание
Занести в столбец str_id таблицы applicant_order нумерацию абитуриентов, которая начинается с 1 для каждой образовательной программы.     
Пояснение
В запросе на обновление используйте вложенный запрос , в котором нумеруются записи таблицы applicant_order по образовательным программам. В качестве условия соединения таблицы и вложенного запроса после ключевого слова   указать, что id программ в таблице applicant_order и во вложенном запросе совпадают, а также id абитуриентов в таблице applicant_order и во вложенном запросе совпадают. (СПИСАЛ, САМ РЕШИТЬ НЕ СМОГ, СБИЛО В УСЛОВИЯХ ЗАДАЧИ 
, ЧТО НУЖНО СДЕЛАТЬ ВЛОЖЕННЫЙ ЗАПРОС. УЖЕ 2 ПРИМЕРА НЕ СМОГ РЕШИТЬ ИЗ КУРСА И СПИСАЛ. ПЕЧАЛЬКА)

set @row_num := 1;
set @num_pr := 0;
update applicant_order
set str_id = if(program_id = @num_pr, @row_num := @row_num + 1, @row_num := 1 and @num_pr := @num_pr + 1);
select * from applicant_order;
------------------------------------------------------------------------------------------------------          
		3.4.8
Задание
Создать таблицу student,  в которую включить абитуриентов, которые могут быть рекомендованы к зачислению  в соответствии с планом набора. Информацию отсортировать сначала в алфавитном порядке по названию программ, а потом по убыванию итогового балла.
На каждую образовательную программу может быть зачислено только обозначенное в плане число абитуриентов (например, n). Выбираются первые n абитуриентов, набравших наибольшее количество баллов. В str_id содержится нумерация (отсортированных по сумме баллов абитуриентов), начинающаяся с 1 для каждой образовательной программы. И соответственно, если по плану нужно зачислить n абитуриентов, то выбираются все абитуриенты, порядковый номер которых в str_id меньше или равен n.
То есть в таблицу на каждую образовательную программу включить абитуриентов, значение str_id которых в таблице applicant_order меньше или равно плану

create table student as
select p.name_program, e.name_enrollee, ao.itog
from enrollee e 
    inner join applicant_order ao on ao.enrollee_id = e.enrollee_id
    inner join program p on p.program_id = ao.program_id
where ao.str_id <= p.plan
order by 1, 3 desc;
select * from student;
------------------------------------------------------------------------------------------------------          
		3.5.2
Задание
Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:
    в поле Модуль указать номер модуля и его название через пробел;
    в поле Урок указать номер модуля, порядковый номер урока (lesson_position) через точку и название урока через пробел;
    в поле Шаг указать номер модуля, порядковый номер урока (lesson_position) через точку, порядковый номер шага (step_position) через точку и название шага через пробел.
Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию номеров модулей, порядковых номеров уроков и порядковых номеров шагов.

select concat(left(concat(m.module_id, ' ', m.module_name), 16), '...') as Модуль,
       concat(left(concat(m.module_id, '.', l.lesson_position, ' ', l.lesson_name), 16), '...') as Урок,
       concat(m.module_id, '.', l.lesson_position, '.', s.step_position, ' ', s.step_name) as Шаг
from step s 
    inner join lesson l on l.lesson_id = s.lesson_id
    inner join module m on m.module_id = l.module_id
where s.step_name like '%ложенн%'
order by 1, 2, 3;



------------------------------------------------------------------------------------------------------          
		3.5.3
/*
Еще одна возможность улучшить навигацию по курсу - это реализация поиска шагов по ключевым словам. Для этого необходимо создать таблицу с терминами keyword, а затем связать ее с таблицей step через вспомогательную таблицу step_keyword. Каждая запись этой таблицы - это id шага и id встречающегося на этом шаге ключевого слова.
Задание
Заполнить таблицу step_keyword следующим образом: если ключевое слово есть в названии шага, то включить в step_keyword строку с id шага и id ключевого слова. 
REGEXP_INSTR(string, pat) делает то же самое, что и INSTR(string1, string2), только вторым аргументом можно подставить регулярное выражение. Символ конца слова надо набирать как \\b, если что.*/

insert into step_keyword
select s.step_id, k.keyword_id
from step s, keyword k
where regexp_instr(s.step_name , concat('\\b', k.keyword_name, '\\b'));
select * from step_keyword;


------------------------------------------------------------------------------------------------------          
		3.5.4
Задание
Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова MAX и AVG одновременно. Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать Шаг. Информацию отсортировать по первому столбцу в алфавитном порядке.

select concat(m.module_id, '.', l.lesson_position, '.', if(s.step_position < 10, concat(0,  s.step_position), s.step_position), ' ', s.step_name) as Шаг 
from module m
    inner join lesson l on m.module_id = l.module_id
    inner join step s on l.lesson_id = s.lesson_id
    inner join step_keyword sk on s.step_id = sk.step_id
    inner join keyword k on k.keyword_id = sk.keyword_id
where k.keyword_name = 'max' or k.keyword_name = 'avg'
group by 1
having count(*) = 2 
order by 1;
------------------------------------------------------------------------------------------------------          		3.5.5     
Задание
Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.

/*
Отнести каждого студента к группе,  в зависимости от пройденных заданий:

select tt.student_name, tt.rate,
    case
        when rate <= 10 then 'I'
        when rate <= 15 then 'II'
        when rate <= 27 then 'III'
        else 'IV'
    end as Группа
from (
select t.student_name, count(*) as rate
from 
    (
     select student_name, step_id
     from student
         inner join step_student using(student_id)
     where result = 'correct'
     group by student_name, step_id
     order by 1
     ) t
group by student_name
order by 2
    ) tt;*/
/*
Задание
Посчитать, сколько студентов относится к каждой группе. Столбцы назвать Группа, Интервал, Количество. Указать границы интервала.*/

select ttt.group_rate as Группа
       ,case when ttt.group_rate = 'I' then 'от 0 до 10'
            when ttt.group_rate = 'II' then 'от 11 до 15'
            when ttt.group_rate = 'III' then 'от 16 до 27'
            else 'больше 27'
            end as Интервал
       ,count(ttt.group_rate) as Количество
from 
(
select tt.student_name, tt.rate, 
    case 
        when tt.rate <= 10 then 'I'
        when tt.rate <= 15 then 'II'
        when tt.rate <= 27 then 'III'
        else 'IV'
    end as group_rate    
from
(select t.student_name, count(*) as rate
from (
    select s.student_name, ss.step_id
    from student s 
        inner join step_student ss using(student_id)
    where ss.result = 'correct'
    order by s.student_name
    ) t
group by t.student_name
order by 2
) tt
) ttt
group by ttt.group_rate
order by ttt.group_rate;
------------------------------------------------------------------------------------------------------         
		3.5.6



------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               



------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               


------------------------------------------------------------------------------------------------------               









