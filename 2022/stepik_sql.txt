1.2
--------------------------------------------------

Задание
При анализе продаж книг выяснилось, что наибольшей популярностью пользуются книги Михаила Булгакова, на втором месте книги Сергея Есенина. Исходя из этого решили поднять цену книг Булгакова на 10%, а цену книг Есенина - на 5%. Написать запрос, куда включить автора, название книги и новую цену, последний столбец назвать new_price. Значение округлить до двух знаков после запятой.

/*select title, amount, price,
    round(if(amount<4, (price * 0.5), if(amount<11, price * 0.7, price*0.9)), 2) as sale,
    if(amount < 4, 'скидка 50%', if(amount < 11, 'скидка 30%', 'скидка 10%')) as Ваша_скидка 
from book; */
select author, title, round(if(author = 'Булгаков М.А.', price * 1.1, if(author = 'Есенин С.А.', price * 1.05, price)), 2) as new_price
from book;

--------------------------------------------------

Вывести автора, название  и цены тех книг, количество которых меньше 10.

select author, title, price
from book
where amount < 10;

---------------------------------------------------

Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

/*select title, author, price
from book
where author = 'Булгаков М.А.' and price > 600;    
select title, author, price
from book
where (author = 'Есенин С.А.' or author = 'Булгаков М.А.') and price > 600;*/

select title, author, price, amount
from book
where (price < 500 or price > 600) and (price*amount >= 5000);

---------------------------------------------------

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

select title, author
from book
where (price between 540.50 and 800) and (amount in (2,3,5,7));

---------------------------------------------------

Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

select author, title
from book
where amount between 2 and 14
order by author desc, title;

---------------------------------------------------

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

select title, author
  from book
 where title like '_% _%' 
   and (author like '% С._.'
    or author like '% _.С.')
 order by title;
   
----------------------------------------------------

Придумайте один или несколько запросов к нашей таблице book. Проверьте, правильно ли они работают.

select author
from book
group by author

----------------------------------------------------------------
Отобрать различные (уникальные) элементы столбца amount таблицы book.

select distinct amount
from book;

--------------------------------------

Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.

select author as Автор, count(author) as Различных_книг, sum(amount) as Количество_экземпляров
from book
group by author;

---------------------------------------------------
			Выборка данных, групповые функции MIN, MAX и AVG

Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.

select author, min(price) as Минимальная_цена, max(price) as Максимальная_цена, avg(price) as Средняя_цена
from book
group by author;

---------------------------------------------------
			Выборка данных c вычислением, групповые функции		
Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой. В запросе для расчета НДС(tax)  и Стоимости без НДС(S_without_tax) использовать следующие формулы: 
tax=((s*k/100)/(1+k/100)
S_without_tax = (s/(1+k/100))

select author, sum(price * amount) as Стоимость
     , round((sum(price * amount) * 0.18/1.18),2) as НДС
     , round(((sum(price * amount))/1.18),2) as Стоимость_без_НДС  
from book
group by author;

---------------------------------------------------
			Вычисления по таблице целиком
Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой. Пояснение. В задании нужно посчитать среднюю цену уникальных книг на складе, а не среднюю цену всех экземпляров книг.

select 
	min(price) as Минимальная_цена
       ,max(price) as Максимальная_цена
       ,round(((sum(price))/count(author)),2) as Средняя_цена
from book
--group by author;
---------------------------------------------------
			Выборка данных по условию, групповые функции
Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.

select
    round(avg(price),2) as Средняя_цена
   ,round(sum(price * amount),2) as Стоимость
from book
where amount between 5 and 14;


---------------------------------------------------
			Выборка данных по условию, групповые функции, WHERE и HAVING

Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.

select author, sum(price * amount) as Стоимость
from book
where title <> 'Идиот' and title <> 'Белая гвардия'
group by author
having sum(price * amount) > 5000  
--так то тут неправильно, должно было быть having round(sum(price * amount) > 5000
order by sum(price * amount) desc

---------------------------------------------------
			Вложенный запрос, возвращающий одно значение
Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

select author, title, price
from book
where price <= (select avg(price) from book) 
order by price desc;

---------------------------------------------------
			Использование вложенного запроса в выражении
Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.

select author, title, price
from book
where (price - (select min(price) from book)) <= 150
order by price
---------------------------------------------------
			Вложенный запрос, оператор IN
Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется. Пояснение в решению: во вложенном запросе отберите те значения столбца amount, количество которых, вычисленное с помощью функции count(), равно 1. 

select author, title, amount
from book
where amount in (select amount
                 from book
                 group by amount
                 having count(amount) = 1
                );
---------------------------------------------------
			Вложенный запрос, операторы ANY и ALL (только во вложенном можно использовать any и all)
Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.

select author, title, price
from book
where price < any(
                    select min(price)
                    from book
                    group by author
                    );

---------------------------------------------------
				Вложенный запрос после SELECT
Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно.

select title, author, amount,(
    (
        select max(amount)
        from book)
        - amount) as Заказ
from book
where ((select max(amount) from book) - amount) > 0;

---------------------------------------------------
Создание таблицы осуществляется с помощью запроса CREATE, подробно рассмотренного в первом уроке модуля.

create table supply(
     supply_id int primary key auto_increment
    ,title varchar(50)
    ,author varchar(30)
    ,price decimal(8,2)
    ,amount int
    );


---------------------------------------------------
				Добавление записей в таблицу
Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:

insert into supply(title, author, price, amount)
values
    ('Лирика', 'Пастернак Б.Л.', 518.99, 2)
   ,('Черный человек', 'Есенин С.А.', 570.20, 6)
   ,('Белая гвардия', 'Булгаков М.А.', 540.50, 7)
   ,('Идиот', 'Достоевский Ф.М.', 360.80, 3);
---------------------------------------------------
				Добавление записей из другой таблицы
Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

insert into book (title, author, price, amount)
select title, author, price, amount
from supply
where author not in ('Булгаков М.А.', 'Достоевский Ф.М.')
---------------------------------------------------
				Добавление записей, вложенные запросы
Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.
(также пришлось убрать автора Есенин С.А, так как в результирущем ответе его не должно было быть)

insert into book (title, author, price, amount)
select title, author, price, amount
from supply
where title not in(
    select title
    from book
    ) and not author = 'Есенин С.А.'; 
select * from book


---------------------------------------------------
				Запросы на обновление
Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы.

update book
set price = 0.9 * price
where amount between 5 and 10;
select * from book;


---------------------------------------------------
				Запросы на обновление нескольких столбцов
В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.

update book
set buy = if(buy >= amount, amount, buy)
   ,price = if(buy > 0, price, 0.9*price);
select * from book;

---------------------------------------------------
				Запросы на обновление нескольких таблиц
В запросах на обновление можно использовать несколько таблиц, но тогда

    для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
    все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
    в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.

Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).

update book, supply
set book.amount = book.amount + supply.amount
   ,book.price = (book.price + supply.price)/2
where book.title = supply.title and book.author = supply.author;

select * from book;

---------------------------------------------------
				Запросы на удаление
Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.

DELETE FROM supply 
WHERE author IN (
        SELECT author 
        FROM book
        group by author
        having sum(amount) > 10
          );

select * from supply;

---------------------------------------------------
				Запросы на создание таблицы
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE.Запрос на создание новой таблицы имеет вид: 
CREATE TABLE имя_таблицы AS
SELECT ...

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

create table ordering as
select author, title, (select round(avg(amount))
                      from book) as amount
from book
where book.amount < (select round(avg(amount))
                    from book);

select * from ordering;

---------------------------------------------------
				1.6
Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

select name, city, per_diem, date_first, date_last
from trip
where name like '%а _._.'
order by date_last desc;

---------------------------------------------------
Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.

select distinct name
from trip
where city = 'Москва'
order by name;

---------------------------------------------------
Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. 

select city, count(city) as Количество 
from trip
group by city
order by city;

---------------------------------------------------
				Оператор LIMIT
Для ограничения вывода записей в SQL используется оператор LIMIT , после которого указывается количество строк.  Результирующая таблица будет иметь количество строк не более указанного после LIMIT. LIMIT размещается после раздела ORDER BY. Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 
Важно. Оператор LIMIT нужно использовать очень осторожно. Например, если бы в таблице trip было несколько командировок с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение таких командировок.

---------------------------------------------------
				Оператор LIMIT
Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.

select city, count(city) as Количество
from trip
group by city
order by count(city) desc
limit 2;

---------------------------------------------------
Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

Немного теории
Для вычитания двух дат используется функция DATEDIFF(дата_1, дата_2), результатом которой является количество дней между дата_1 и дата_2. Увеличьте разницу на 1, чтобы включить первый день командировки.

select name, city, (datediff(date_last, date_first) + 1) as Длительность
from trip
where city not in('Москва', 'Санкт-Петербург')
order by 3 desc, city desc

---------------------------------------------------
Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить столбцы name, city, date_first, date_last. Пояснение: используйте вложенный запрос, чтобы найти длительность самой короткой командировки. 

select name, city, date_first, date_last
from trip
where datediff(date_last, date_first) = (select min(datediff(date_last, date_first))
                                         from trip
                                        order by 1);

---------------------------------------------------

Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .
	Немного теории: для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).
Например, MONTH('2020-04-12') = 4.
Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)

select name, city, date_first, date_last
from trip
where month(date_first) = month(date_last)
order by city, name;

---------------------------------------------------
Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Немного теории

    Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название месяца на английском языке для указанной даты. Например, MONTHNAME('2020-04-12')='April'.
    Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после GROUP BYможно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS. Важно отметить, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

select monthname(date_first) as Месяц, count(monthname(date_first)) as Количество
from trip
group by monthname(date_first)
order by count(monthname(date_first)) desc, monthname(date_first) 

---------------------------------------------------
Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem. Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

select name, city, date_first, (per_diem * (datediff(date_last, date_first)+1)) as Сумма
from trip
where month(date_first) = 2 or month(date_first) = 3 
order by name, 4 desc;

---------------------------------------------------
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма.

select name, sum((datediff(date_last, date_first) + 1) * per_diem) as Сумма 
from trip
group by name
having count(name) > 3
order by 2 desc

---------------------------------------------------
https://stepik.org/lesson/305762/step/2?unit=287773
Создать таблицу fine следующей структуры:

create table fine (
                     fine_id INT PRIMARY KEY AUTO_INCREMENT
                    , name varchar(30)
                    , number_plate varchar(6)
                    , violation varchar(50)
                    , sum_fine decimal(8,2)
                    , date_violation date
                    , date_payment date 
                  );

---------------------------------------------------
https://stepik.org/lesson/305762/step/3?unit=287773
В таблицу fine первые 5 строк уже занесены. Добавить в таблицу записи с ключевыми значениями 6, 7, 8.

insert into fine(name, number_plate, violation, sum_fine, date_violation, date_payment)
    values  ('Баранов П.Е.', 'Р523ВТ', 'Превышение скорости(от 40 до 60)', null, '2020-02-14', null)
           ,('Абрамова К.А.', 'О111АВ', 'Проезд на запрещающий сигнал', null, '2020-02-23', null)
           ,('Яковлев Г.Р.', 'Т330ТТ', 'Проезд на запрещающий сигнал', null, '2020-03-03', null);
---------------------------------------------------
			Использование временного имени таблицы (алиаса)


Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.
Таблица traffic_violationсоздана и заполнена.
Важно! Сравнение значения столбца с пустым значением осуществляется с помощью оператора IS NULL.

update fine as f, traffic_violation as tv
set f.sum_fine = tv.sum_fine
where f.sum_fine is null 
and f.violation = tv.violation;

select * from fine;
---------------------------------------------------
				Группировка данных по нескольким столбцам
В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:
((((((((((	Важно! В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не (((((((((       применяются (групповые функции) из SELECT.				)))))))))))))
Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.
Пояснение

Под увеличение  штрафа в два раза подходит водитель «Абрамова К.А.», который на машине с государственным номером «О111АВ» совершил повторное нарушение «Проезд на запрещающий сигнал», а также водитель  «Баранов П.Е.» , который на машине с номером  «Р523ВТ» дважды совершил нарушение «Превышение скорости(от 40 до 60) ».

select f.name, f.number_plate, f.violation  
from fine as f
group by f.name, f.number_plate, f.violation
having count(f.number_plate) = 2 
order by name, number_plate, violation;

---------------------------------------------------
	В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 

    Для всех нарушений, по которым штраф еще не оплачен, (тех, у которых date_payment имеет пустое значение Null), необходимо проверить, является ли данное нарушение для водителя и машины повторным, если да –  увеличить штраф в два раза.
    Если водитель совершил нарушение на другой машине, ему увеличивать штраф не нужно.
    Если несколько повторных нарушений не оплачены, то штраф увеличить для всех.
    Этот запрос реализован на предыдущем шаге.
При реализации можно использовать вложенный запрос как отдельную таблицу, записанную после ключевого слова UPDATE, при этом вложенному запросу необходимо присвоить имя, например query_in:

UPDATE fine, 
    (
     SELECT ...
    ) query_in
SET ...
WHERE указать, что совпадают нарушение, фамилия водителя и номер машины в таблицах fine и вложенном запросе query_in соответственно, а также дата оплаты в таблице fine пуста

Другим способом решения является использование двух запросов: сначала создать временную таблицу, например query_in, в которую включить информацию о тех штрафах, сумму которых нужно увеличить в два раза, а затем уже обновлять информацию в таблице fine:

CREATE TABLE query_in ...;
UPDATE fine, query_in
SET ...
WHERE ...;

После ключевого слова WHERE  указывается условие, при котором нужно обновлять данные. В нашем случае  данные обновляются, если и фамилия, и государственный номер, и нарушение совпадают в таблице fine и в результирующей таблице запроса query_in. Например, для связи по фамилии используется запись fine.name = query_in.name. Также в условии нужно учесть, что данные обновляются только для тех записей, у которых в столбце date_payment пусто.
Важно! Если в запросе используется несколько таблиц или запросов, включающих одинаковые поля, то применяется полное имя столбца, включающего название таблицы через символ «.». Например,  fine.name  и  query_in.name.

create table query_in as (select f.name, f.number_plate, f.violation
                          from fine as f
                          group by f.name, f.number_plate, f.violation
                          having count(*) > 1);
update fine as f, query_in as q
set sum_fine = sum_fine * 2
where f.date_payment is null and
(f.name, f.number_plate, f.violation) = (q.name, q.number_plate, q.violation);
select * from fine;


-- или where f.date_payment is null and f.name = q.name and f.number_plate = q.number_plate and f.violation = --q.violation;
вот это решение ниже, тоже верное

update fine as f, (select f.name, f.number_plate, f.violation
                          from fine as f
                          group by f.name, f.number_plate, f.violation
                          having count(*) > 1) as query_in
set sum_fine = sum_fine * 2
where f.date_payment is null and
(f.name, f.number_plate, f.violation) = (query_in.name, query_in.number_plate, query_in.violation);
select * from fine;

---------------------------------------------------
Задание
Необходимо:
    в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
    уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов, информация о которых занесена в таблицу payment) , если оплата произведена не позднее 20 дней со дня нарушения.

 update fine as f, payment as p
    set f.date_payment = p.date_payment,
        f.sum_fine = if(datediff(p.date_payment, p.date_violation) < 20+1, 0.5 * f.sum_fine, f.sum_fine)
  where f.name = p.name
    and f.number_plate = p.number_plate
    and f.violation = p.violation
    and f.date_payment is null;
 select * from fine;

---------------------------------------------------
Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

create table back_payment as
select f.name, f.number_plate, f.violation, f.sum_fine, f.date_violation
from fine as f
where f.date_payment is null;
select * from back_payment;

---------------------------------------------------
Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 

delete from fine
where date_violation < '2020-02-01 ';
select * from fine;

---------------------------------------------------

Поиск по ключевым словам

На данном шаге можно найти шаги курса, в которых встречаются ключевые слова SQL, которые рассматриваются в курсе.

Для этого скопируйте один из запросов в окно решений, укажите нужные ключевые слова и запустите запрос. В окне решений будут выведены ссылки на соответствующие шаги.

Это НЕ ЗАДАНИЕ, а просто запросы, с помощью которых можно найти шаги, в которых встречаются те или иные ключевые слова. Выполнять не обязательно (это задание оценивается в 0 баллов). Это ПРОСТО ПОМОЩЬ для навигации по курсу.

Запрос 1. Поиск шагов, в которых встречается заданное ключевое слово, в примере MAX:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ", CONCAT(LEFT(step_name, 50), '...')) AS Шаг,
   note AS Примечание
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name = 'MAX'
ORDER BY 1;

Запрос 2. Поиск шагов, в которых встречаются два заданных ключевых слова одновременно, в примере MAX и AVG:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ", CONCAT(LEFT(step_name, 30), '...')) AS Шаг, 
   link AS Ссылка_на_шаг
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG')
GROUP BY ШАГ, Ссылка_на_шаг
HAVING count(*) = 2
ORDER BY 1;

 Запрос 3. Поиск шагов, в которых встречаются три заданных ключевых слова одновременно, в примере MAX, MIN и AVG:

SELECT 
   CONCAT(module_id,'.',lesson_position,".",step_position," ",step_name) AS Шаг
FROM step
        INNER JOIN lesson USING(lesson_id)
        INNER JOIN module USING(module_id)
        INNER JOIN step_keyword USING(step_id)
        INNER JOIN keyword USING(keyword_id)
WHERE keyword_name IN ('MAX', 'AVG', 'MIN')
GROUP BY ШАГ
HAVING COUNT(*) = 3
ORDER BY 1;


---------------------------------------------------
				2.1. СВЯЗИ МЕЖДУ ТАБЛИЦАМИ

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы. 
Этапы реализации связи «один ко многим» на примере:
	1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе.
	2. Обе таблицы должны содержать первичный ключ (PK): book_id - в таблице  book,  author_id -  в таблице author.
	3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id)
---------------------------------------------------
Создать таблицу author следующей структуры:

create table author (author_id int primary key auto_increment,
                     name_author varchar(50)
                    );


---------------------------------------------------
Заполнить таблицу author. В нее включить следующих авторов:

    Булгаков М.А.
    Достоевский Ф.М.
    Есенин С.А.
    Пастернак Б.Л.

insert into author (name_author)
values ('Булгаков М.А.'),
       ('Достоевский Ф.М.'),
       ('Есенин С.А.'),
       ('Пастернак Б.Л.');


---------------------------------------------------
Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре, показанной на логической схеме (таблица genre уже создана, порядок следования столбцов - как на логической схеме в таблице book, genre_id  - внешний ключ) . Для genre_id ограничение о недопустимости пустых значений не задавать. В качестве главной таблицы для описания поля  genre_idиспользовать таблицу genre следующей структуры:

create table book (book_id int primary key auto_increment,
                   title varchar(50),
                   author_id int not null,
                   genre_id int,
                   price decimal(8, 2),
                   amount int,
                   foreign key(author_id) references author(author_id),
                   foreign key(genre_id) references genre(genre_id)
                   );


---------------------------------------------------
Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 

create table book (
    book_id int primary key auto_increment,
    title varchar(50),
    author_id int not null,
    genre_id int,
    price decimal(8,2),
    amount int,
    foreign key (author_id) references author (author_id) on delete cascade,
    foreign key (genre_id) references genre (genre_id) on delete set null
);
---------------------------------------------------
Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:

insert into book (title, author_id, genre_id, price, amount)
values ('Стихотворения и поэмы', 3, 2, 650.00, 15),
       ('Черный человек', 3, 2, 570.20, 6),
       ('Лирика', 4, 2, 518.99, 2);
select * from book;

---------------------------------------------------
			2.2 Соединение INNER JOIN
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

select title, name_genre, price
from book as b
inner join genre as g on g.genre_id = b.genre_id
where amount > 8
order by price desc

---------------------------------------------------
			    Вывести все жанры, которые не представлены в книгах на складе.

/*select
...
from 
    таблица_1 left join таблица_2
    on условие
... */
/* 
select name_author, title
from author left join book
    on author.author_id = book.author_id
order by name_author; 

--ниже то же самое, только переставил таблица, куда джонйнят (book)

select name_author, title
from book left join author on author.author_id = book.author_id
order by name_author;
select * from author;
select * from book;
*/
select name_genre
from genre as g left join book as b on g.genre_id = b.genre_id
where b.title is null;

с комментариев интересное решениепри помощи exists
SELECT g.name_genre
FROM genre g
WHERE NOT EXISTS(SELECT * from book b WHERE b.genre_id = g.genre_id);

---------------------------------------------------
					Перекрестное соединение CROSS JOIN
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

select c.name_city, a.name_author, date_add('2020-01-01', interval (floor(rand() * 365)) day) as Дата
from city as c, author as a
--date_add('2020-01-01', interval floor(rand() * 365)) --прибавляем к начальной дате 2020-01-01 сгенерированное 
-- число
order by c.name_city, 3 desc

---------------------------------------------------
					Запросы на выборку из нескольких таблиц
 Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

/*
table first ------>  table second (в первой таблице есть первичный ключ как и во второй, внешний ключ во второй таблице)
table second ----->  table third (--//--- как и в first ----> second)
*/
/*
select
...
from 
    first
    inner join second on first.first_id = second.first_id
    inner join third on second.second_id = third.second_id;
*/
/*
table first ------>   table third
table second ----->   table third
у каждого есть первичный ключ, первая и вторая указыают на третью на внешний ключ.
*/
/*
select
...
from 
    first
    inner join third on first.first_id = third.first_id
    inner join second on second.second_id = third.second_id;  
*/   
select g.name_genre, b.title, a.name_author
from 
    genre as g 
    inner join book as b on g.genre_id = b.genre_id
    inner join author as a on a.author_id = b.author_id
where g.name_genre = 'Роман'
order by title

---------------------------------------------------
				Запросы для нескольких таблиц с группировкой

Посчитать количество экземпляров  книг каждого автора из таблицы author.  Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.

/* из-за inner не входят в выборку авторы, у которых нет книг
    select name_author, count(title) as Количество
    from author inner join book on author.author_id = book.author_id
    group by name_author
    order by name_author;
*/
/* сюда же авторы без книг уже входят
select name_author, count(title) as Количество
from 
    author left join book on author.author_id = book.author_id
group by name_author
order by name_author;
*/

select a.name_author, sum(b.amount) as Количество
from author as a left join book as b on a.author_id = b.author_id
group by a.name_author
having (sum(b.amount) < 10 or sum(b.amount) is null)
order by sum(b.amount);
---------------------------------------------------
--Пример, вывести авторов, общее количество книг которых на складе максимаьно
/*    это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объеденим все запросы в один.
    Шаг 1. Найдем суммарное колиечество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id
*/
select b.author_id, sum(b.amount) as sum_amount
from book as b
group by b.author_id;
/* 
    Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присовить имя (например, query_in) и использовать его в качестве таблицы-источника после from. Затем уже находить максимум по столбцу sum_amount.
*/
select max(sum_amount) as max_sum_amount
from 
    (
     select b.author_id, sum(b.amount) as sum_amount
    from book as b
    group by b.author_id
    ) query_in;
/* Теперь собственно осталось только добавить к этому результату нижнему автора книги (мои мысли)
    Шаг 3. (теперь уже из курса) выведем фамилию автора и общее количество книг для него
*/
select a.name_author, sum(amount) as Количество
from author as a 
    inner join book as b on a.author_id = b.author_id
group by a.name_author;

/*
    Шаг 4. Включим запрос с шаг 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количесвто книг которых максимально
*/

select a.name_author, sum(amount) as Количество
from author as a 
    inner join book as b on a.author_id = b.author_id
group by a.name_author
having sum(amount) = 
    ( /*вычисляем максимальное из общего количества книг каждого автора */
        select max(sum_amount) as max_sum_amount
        from 
            (/* считаем количество книг каждого автора */
             select b.author_id, sum(b.amount) as sum_amount
             from book as b
             group by b.author_id
            ) query_in
    );
				




Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).
---------------------------------------------------
				Запросы для нескольких таблиц со вложенными запросами

/*Задача :вывести авторов, общее количество книг которых на складе максимально

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один
*//*

шаг 1. 
Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии авторов в этой таблице нет, то группировку будем осуществлять по author_id */
select b.author_id, sum(b.amount) as sum_amount
from book as b
group by b.author_id;
/*

Шаг 2. В результрирущей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать его в качестве таблицы-источника после from. Затем уже находить максимум по столбцу sum_amount. */
select max(query_in.sum_amount) as max_sam_amount
from (
    select b.author_id, sum(b.amount) as sum_amount
    from book as b
    group by b.author_id
    ) query_in;

/*Шаг 3. Выведем фамилию автора и общее количество книг для него*/
select a.name_author, sum(b.amount) as Количество
from author as a inner join book as b on a.author_id = b.author_id
group by a.name_author;

/*Шаг 4. Включим в запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.*/
select a.name_author, sum(b.amount) as Количество
from author as a inner join book as b on a.author_id = b.author_id
group by a.name_author
having sum(b.amount) = 
    (/* вычисляем максимальное из общего количества книг каждого автора */
        select max(sum_amount) as max_sum_amount
        from 
            (/* считаем количество книг каждого автора */
                select b.author_id, sum(b.amount) as sum_amount
                from book as b
                group by b.author_id
                ) query_in
    );    

 

---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------



---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------



---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------


---------------------------------------------------









